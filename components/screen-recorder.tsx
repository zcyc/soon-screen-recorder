'use client';

import { useState, useRef, useCallback, useEffect } from 'react';
import LoginModal from '@/components/login-modal';

// Web Speech API types
declare global {
  interface Window {
    SpeechRecognition: any;
    webkitSpeechRecognition: any;
  }
}

interface SpeechRecognitionEvent extends Event {
  results: SpeechRecognitionResultList;
  resultIndex: number;
}

interface SpeechRecognitionErrorEvent extends Event {
  error: string;
  message?: string;
}

interface SpeechRecognitionResult {
  readonly isFinal: boolean;
  readonly [index: number]: SpeechRecognitionAlternative;
}

interface SpeechRecognitionAlternative {
  readonly transcript: string;
  readonly confidence: number;
}

interface SpeechRecognitionResultList {
  readonly length: number;
  item(index: number): SpeechRecognitionResult;
  readonly [index: number]: SpeechRecognitionResult;
}

interface SpeechRecognition extends EventTarget {
  continuous: boolean;
  interimResults: boolean;
  lang: string;
  maxAlternatives: number;
  start(): void;
  stop(): void;
  onstart: ((this: SpeechRecognition, ev: Event) => any) | null;
  onend: ((this: SpeechRecognition, ev: Event) => any) | null;
  onresult: ((this: SpeechRecognition, ev: SpeechRecognitionEvent) => any) | null;
  onerror: ((this: SpeechRecognition, ev: SpeechRecognitionErrorEvent) => any) | null;
}
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Switch } from '@/components/ui/switch';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { 
  Monitor, 
  Camera, 
  Mic, 
  Square, 
  Play, 
  Pause, 
  Download,
  Upload,
  Settings,
  MicOff,
  CameraOff,
  Share2,
  Copy,
  ExternalLink,
  Link,
  Circle,
  StopCircle,
  Globe
} from 'lucide-react';
import { useAuth } from '@/contexts/auth-context';
import { RECORDING, SUBTITLES, PERMISSIONS, COMMON, GUEST, VIDEOS, PUBLISH, DEVICES } from '@/lib/constants';
import { isInIframe, isMediaAccessBlocked, openInNewWindow, getIframeRestrictionMessage } from '@/lib/iframe-detector';
import { recordingConfig } from '@/lib/config';
import { uploadVideoFileAction } from '@/app/actions/video-actions';
import { detectBrowser as detectBrowserFromLib } from '@/lib/browser-compatibility';

import { getFileUrlAction, uploadFileAction, updateVideoThumbnailAction } from '@/app/actions/video-actions';
import { generateVideoThumbnailBlob } from '@/lib/video-utils';

// Utility function to check Permissions Policy support
const checkPermissionsPolicy = (): { supported: boolean; allowed: boolean; error?: string } => {
  try {
    // Check if Permissions Policy API is available
    if (typeof document !== 'undefined' && 'featurePolicy' in document) {
      const policy = (document as any).featurePolicy;
      if (policy && typeof policy.allowsFeature === 'function') {
        const displayCaptureAllowed = policy.allowsFeature('display-capture');
        return { supported: true, allowed: displayCaptureAllowed };
      }
    }
    
    // Check for newer Permissions Policy API
    if (typeof document !== 'undefined' && 'permissionsPolicy' in document) {
      const policy = (document as any).permissionsPolicy;
      if (policy && typeof policy.allowsFeature === 'function') {
        const displayCaptureAllowed = policy.allowsFeature('display-capture');
        return { supported: true, allowed: displayCaptureAllowed };
      }
    }
    
    // If no Permissions Policy API, assume allowed (older browsers)
    return { supported: false, allowed: true };
  } catch (error) {
    console.warn('Error checking Permissions Policy:', error);
    return { supported: false, allowed: true, error: (error as Error).message };
  }
};

type RecordingQuality = '720p' | '1080p';
type RecordingSource = 'screen' | 'camera' | 'both' | 'camera-only';
type ScreenSourceType = 'monitor' | 'window' | 'browser';

interface SubtitleSegment {
  id: string;
  startTime: number;
  endTime: number;
  text: string;
  confidence: number;
}

interface SubtitleState {
  isEnabled: boolean;
  language: string;
  segments: SubtitleSegment[];
  currentText: string;
  isListening: boolean;
}

interface RecordingState {
  isRecording: boolean;
  isPaused: boolean;
  duration: number;
  recordedBlob: Blob | null;
}

// ÁÆÄÂåñÁöÑËßÜÈ¢ëÈ¢ÑËßàÁªÑ‰ª∂
const RestoreableVideo: React.FC<{
  blob: Blob | null;
  className?: string;
}> = ({ blob, className }) => {
  const [videoSrc, setVideoSrc] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoaded, setIsLoaded] = useState<boolean>(false);
  const videoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (!blob) {
      setVideoSrc(null);
      setError(null);
      return;
    }

    let objectUrl: string | null = null;

    try {
      // Âü∫Êú¨È™åËØÅ
      if (!blob || blob.size === 0) {
        setError('Invalid video data');
        return;
      }
      
      if (!(blob instanceof Blob)) {
        setError('Invalid video data type');
        return;
      }

      // Ê£ÄÊü•Êñá‰ª∂Â§ßÂ∞è
      if (blob.size > 500 * 1024 * 1024) { // Â§ß‰∫é500MB
        setError('Video file too large (over 500MB)');
        return;
      }
      
      // ÂàõÂª∫ URL
      objectUrl = URL.createObjectURL(blob);
      setVideoSrc(objectUrl);
      setError(null);
      
      console.log('Video preview ready:', {
        size: blob.size,
        type: blob.type,
        sizeKB: Math.round(blob.size / 1024)
      });
      
    } catch (err: any) {
      console.error('Failed to create video URL:', err);
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
      setError(`Video loading failed: ${err.message}`);
      setVideoSrc(null);
    }

    // Ê∏ÖÁêÜÂáΩÊï∞
    return () => {
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
    };
  }, [blob]);

  const handleVideoError = (e: React.SyntheticEvent<HTMLVideoElement, Event>) => {
    const video = e.target as HTMLVideoElement;
    console.error('Video playback error:', {
      errorCode: video.error?.code,
      errorMessage: video.error?.message,
      blobSize: blob?.size,
      blobType: blob?.type
    });
    
    let errorMessage = 'Video playback failed';
    if (video.error) {
      switch (video.error.code) {
        case 1: errorMessage = 'Video loading interrupted'; break;
        case 2: errorMessage = 'Network error'; break;
        case 3: errorMessage = 'Video decoding failed'; break;
        case 4: errorMessage = 'Video format not supported'; break;
        default: errorMessage = `Video error (${video.error.code})`;
      }
    }
    setError(errorMessage);
  };

  const handleVideoLoad = () => {
    setError(null);
    setIsLoaded(true);
  };

  const handleVideoLoadedMetadata = () => {
    setError(null);
    setIsLoaded(true);
    
    // Safari ÁâπÊÆäÂ§ÑÁêÜÔºöÂº∫Âà∂ÊòæÁ§∫Á¨¨‰∏ÄÂ∏ß
    if (videoRef.current) {
      const browser = detectBrowserFromLib();
      
      if (browser.isSafari) {
        console.log('üçé Safari video metadata loaded, preparing to display first frame...');
        
        // SafariÈúÄË¶ÅÊòæÂºèÂú∞ÂØªÂùÄÂà∞Á¨¨‰∏ÄÂ∏ßÊù•Ëß¶ÂèëÁîªÈù¢ÊòæÁ§∫
        const video = videoRef.current;
        
        // ÊñπÊ≥ï1ÔºöËÆæÁΩÆcurrentTimeÊù•Âº∫Âà∂Âä†ËΩΩÁ¨¨‰∏ÄÂ∏ß
        video.currentTime = 0.1;
        
        // ÊñπÊ≥ï2Ôºö‰ΩøÁî®loadeddata‰∫ã‰ª∂Á°Æ‰øùÁîªÈù¢ÊòæÁ§∫
        const handleLoadedData = () => {
          console.log('üçé Safari video data loaded, first frame should be visible');
          video.removeEventListener('loadeddata', handleLoadedData);
          
          // Á°Æ‰øùËßÜÈ¢ëÂú®Á¨¨‰∏ÄÂ∏ßÊöÇÂÅú
          if (!video.paused) {
            video.pause();
          }
        };
        
        video.addEventListener('loadeddata', handleLoadedData);
        
        // ÊñπÊ≥ï3ÔºöÂº∫Âà∂Ê∏≤Êüì
        setTimeout(() => {
          if (video.readyState >= 2) { // HAVE_CURRENT_DATA
            video.currentTime = 0;
            console.log('üçé Safari forced to first frame');
          }
        }, 50);
      }
    }
  };

  if (error) {
    return (
      <div className={`flex items-center justify-center bg-destructive/10 border border-destructive/20 rounded-lg ${className}`}>
        <div className="text-center text-sm p-4">
          <div className="mb-3">
            <div className="w-12 h-12 mx-auto mb-2 rounded-full bg-destructive/20 flex items-center justify-center">
              <span className="text-destructive text-xl">‚ö†Ô∏è</span>
            </div>
            <p className="font-medium text-destructive">{error}</p>
          </div>
          <div className="text-xs text-muted-foreground mb-3">
            <p>Please try recording the video again</p>
          </div>
        </div>
      </div>
    );
  }

  if (!videoSrc) {
    return (
      <div className={`flex items-center justify-center bg-muted ${className}`}>
        <div className="text-center text-sm text-muted-foreground">
          <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-current mx-auto mb-2"></div>
          <p>Loading video...</p>
        </div>
      </div>
    );
  }

  // Safari ÁâπÊÆäÂ±ûÊÄß
  const browser = detectBrowserFromLib();
  const safariProps = browser.isSafari ? {
    // Safari ÁâπÊÆäÂ±ûÊÄß‰ª•Á°Æ‰øùËßÜÈ¢ëÊ≠£Á°ÆÊòæÁ§∫
    'webkit-playsinline': 'true',
    'x5-video-player-type': 'h5',
    'x5-video-player-fullscreen': 'true'
  } : {};

  return (
    <video
      ref={videoRef}
      className={className}
      controls
      src={videoSrc}
      onError={handleVideoError}
      onLoadedData={handleVideoLoad}
      onLoadedMetadata={handleVideoLoadedMetadata}
      preload={browser.isSafari ? "auto" : "metadata"}
      muted
      playsInline
      crossOrigin="anonymous"
      poster=""
      {...safariProps}
      style={{
        backgroundColor: '#000',
        objectFit: 'contain',
        // Safari ÁâπÊÆäÊ†∑Âºè
        ...(browser.isSafari ? {
          WebkitTransform: 'translateZ(0)',
          WebkitBackfaceVisibility: 'hidden'
        } : {})
      }}
    />
  );
};

export default function ScreenRecorder() {
  const { user } = useAuth();

  const [recordingState, setRecordingState] = useState<RecordingState>({
    isRecording: false,
    isPaused: false,
    duration: 0,
    recordedBlob: null,
  });
  
  const [quality, setQuality] = useState<RecordingQuality>('720p');
  const [source, setSource] = useState<RecordingSource>('screen');
  const [screenSource, setScreenSource] = useState<ScreenSourceType>('monitor');
  const [includeAudio, setIncludeAudio] = useState(false);
  const [includeCamera, setIncludeCamera] = useState(false);
  const [isUploading, setIsUploading] = useState(false);

  const [videoTitle, setVideoTitle] = useState('');
  const [isVideoPublic, setIsVideoPublic] = useState(true); // Default to public for sharing
  const [isVideoPublished, setIsVideoPublished] = useState(false); // Default to not published to discovery
  const [uploadedVideo, setUploadedVideo] = useState<any>(null); // Store uploaded video data

  const [cameraPreviewStream, setCameraPreviewStream] = useState<MediaStream | null>(null); // Camera preview stream
  const [isMounted, setIsMounted] = useState(false); // Track component mount status
  const [showTimeWarning, setShowTimeWarning] = useState(false); // Show time warning
  const [isNearTimeLimit, setIsNearTimeLimit] = useState(false); // Near time limit state
  const [isPiPRequesting, setIsPiPRequesting] = useState(false); // Áîª‰∏≠ÁîªËØ∑Ê±ÇÁä∂ÊÄÅ
  const pipTimeoutRef = useRef<NodeJS.Timeout | null>(null); // Ë∂ÖÊó∂ÂÆöÊó∂Âô®ÂºïÁî®
  
  // Ê∏ÖÁêÜPiPÁä∂ÊÄÅÁöÑÂáΩÊï∞
  const clearPiPState = useCallback(() => {
    if (pipTimeoutRef.current) {
      clearTimeout(pipTimeoutRef.current);
      pipTimeoutRef.current = null;
    }
    setIsPiPRequesting(false);
  }, []);
  
  // ËÆæÁΩÆÂ∏¶Ë∂ÖÊó∂‰øùÊä§ÁöÑPiPËØ∑Ê±ÇÁä∂ÊÄÅ
  const setIsPiPRequestingWithTimeout = useCallback((requesting: boolean) => {
    if (requesting) {
      setIsPiPRequesting(true);
      // ËÆæÁΩÆ3ÁßíË∂ÖÊó∂‰øùÊä§
      pipTimeoutRef.current = setTimeout(() => {
        console.log('PiP request timeout, automatically cleaning up state');
        setIsPiPRequesting(false);
        pipTimeoutRef.current = null;
      }, 3000);
    } else {
      clearPiPState();
    }
  }, [clearPiPState]);
  
  // Subtitle states
  const [subtitleState, setSubtitleState] = useState<SubtitleState>({
    isEnabled: false,
    language: 'zh-CN',
    segments: [],
    currentText: '',
    isListening: false
  });
  const [showSubtitleSettings, setShowSubtitleSettings] = useState(false);
  const [showLoginModal, setShowLoginModal] = useState(false);
  const [recordingError, setRecordingError] = useState<string | null>(null);
  
  // Show toast message


  // ÂêéÂè∞Áº©Áï•ÂõæÁîüÊàêÂáΩÊï∞
  const generateThumbnailInBackground = async (videoId: string, recordedBlob: Blob) => {
    try {
      
      const browser = detectBrowserFromLib();
      console.log(`üé® Starting thumbnail generation for recording ${videoId} in ${browser.name}`);
      
      // Â∞Ü Blob ËΩ¨Êç¢‰∏∫ File ‰ª•‰æõÁº©Áï•ÂõæÁîüÊàê‰ΩøÁî®
      const videoFile = new File([recordedBlob], 'recording.webm', { type: recordedBlob.type });
      
      // ÁîüÊàêÁº©Áï•Âõæ blob
      const thumbnailBlob = await generateVideoThumbnailBlob(videoFile, {
        width: 320,
        height: 180,
        time: 1,
        quality: 0.8,
        format: 'jpeg',
        timeout: browser.isSafari ? 20000 : 15000
      });
      
      console.log('üì∑ Recording thumbnail blob generated, size:', thumbnailBlob.size);
      
      // Â∞Ü Blob ËΩ¨Êç¢‰∏∫ File Âπ∂‰∏ä‰º†
      const thumbnailFile = new File([thumbnailBlob], `thumbnail-${videoId}.jpg`, {
        type: 'image/jpeg'
      });
      
      const uploadResult = await uploadFileAction(thumbnailFile);
      
      if (!uploadResult.success || !uploadResult.data) {
        throw new Error(uploadResult.error || 'Failed to upload thumbnail');
      }
      
      console.log('üîÑ Thumbnail uploaded, updating video record...');
      
      // Êõ¥Êñ∞ËßÜÈ¢ëËÆ∞ÂΩïÁöÑÁº©Áï•Âõæ URL
      const updateResult = await updateVideoThumbnailAction(videoId, uploadResult.data.url);
      
      if (!updateResult.success) {
        throw new Error(updateResult.error || 'Failed to update video thumbnail');
      }
      
      console.log(`‚úÖ Recording thumbnail generated successfully: ${uploadResult.data.url}`);
      
    } catch (error: any) {
      console.error(`‚ùå Recording thumbnail generation failed for video ${videoId}:`, error);
    }
  };
  
  // ÁªÑ‰ª∂Âç∏ËΩΩÊó∂Ê∏ÖÁêÜÂÆöÊó∂Âô®
  useEffect(() => {
    return () => {
      if (pipTimeoutRef.current) {
        clearTimeout(pipTimeoutRef.current);
        pipTimeoutRef.current = null;
      }
    };
  }, []);
  
  // Generate default title for placeholder and fallback
  const getDefaultTitle = () => {
    const now = new Date();
    return `Recording ${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')} ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
  };
  
  const startNewRecording = () => {
    setRecordingState({
      isRecording: false,
      isPaused: false,
      duration: 0,
      recordedBlob: null
    });
    setVideoTitle('');
    setIsVideoPublic(true);
    
    console.log('Starting new recording, resetting state in memory');
    
    setIsVideoPublished(false);
    setUploadedVideo(null);
    
    // Ê∏ÖÈô§ÂΩïÂà∂ÈîôËØØÁä∂ÊÄÅ
    setRecordingError(null);

    setShowTimeWarning(false);
    setIsNearTimeLimit(false);
    // Reset subtitle state
    setSubtitleState(prev => ({
      ...prev,
      segments: [],
      currentText: '',
      isListening: false
    }));
    stopSpeechRecognition();
    // ÈáçÁΩÆÂºÄÂßãÊó∂Èó¥
    recordingStartTimeRef.current = 0;
  };
  
  // Speech Recognition Functions
  const initializeSpeechRecognition = () => {
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {

      return false;
    }
    
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = subtitleState.language;
    recognition.maxAlternatives = 1;
    
    recognition.onstart = () => {
      console.log('Speech recognition started');
      setSubtitleState(prev => ({ ...prev, isListening: true }));
    };
    
    recognition.onresult = (event: SpeechRecognitionEvent) => {
      let interimTranscript = '';
      let finalTranscript = '';
      
      // ËÆ°ÁÆóÂΩìÂâçÊó∂Èó¥Áõ∏ÂØπ‰∫éÂΩïÂà∂ÂºÄÂßãÁöÑÊó∂Èó¥ÔºàÁßíÔºâ
      const currentTime = recordingStartTimeRef.current > 0 
        ? (Date.now() - recordingStartTimeRef.current) / 1000
        : recordingState.duration;
      
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;
        const confidence = event.results[i][0].confidence;
        
        if (event.results[i].isFinal) {
          finalTranscript += transcript;
          // Create subtitle segment with proper timing
          const segmentDuration = Math.min(transcript.length * 0.1, 5); // Ê†πÊçÆÊñáÊú¨ÈïøÂ∫¶‰º∞ÁÆóÊó∂ÈïøÔºåÊúÄÈïø5Áßí
          const segment: SubtitleSegment = {
            id: `subtitle-${Date.now()}-${i}`,
            startTime: Math.max(0, currentTime - segmentDuration), 
            endTime: currentTime,
            text: transcript.trim(),
            confidence: confidence || 0.8
          };
          
          if (segment.text.length > 0) {
            setSubtitleState(prev => ({
              ...prev,
              segments: [...prev.segments, segment],
              currentText: ''
            }));
          }
        } else {
          interimTranscript += transcript;
        }
      }
      
      if (interimTranscript) {
        setSubtitleState(prev => ({ ...prev, currentText: interimTranscript }));
      }
    };
    
    recognition.onerror = (event: SpeechRecognitionErrorEvent) => {
      console.error('ËØ≠Èü≥ËØÜÂà´ÈîôËØØ:', event.error);
      if (event.error === 'not-allowed') {

      } else if (event.error === 'no-speech') {
        // ÈáçÊñ∞ÂêØÂä®ËØÜÂà´
        setTimeout(() => {
          if (subtitleState.isEnabled && recordingState.isRecording) {
            startSpeechRecognition();
          }
        }, 1000);
      }
    };
    
    recognition.onend = () => {
      console.log('Speech recognition ended');
      setSubtitleState(prev => ({ ...prev, isListening: false }));
      
      // Â¶ÇÊûúÂ≠óÂπïÂäüËÉΩ‰ªçÁÑ∂ÂêØÁî®‰∏îÊ≠£Âú®ÂΩïÂà∂ÔºåÈáçÊñ∞ÂêØÂä®ËØÜÂà´
      if (subtitleState.isEnabled && recordingState.isRecording && !recordingState.isPaused) {
        setTimeout(() => {
          startSpeechRecognition();
        }, 500);
      }
    };
    
    speechRecognitionRef.current = recognition;
    return true;
  };
  
  const startSpeechRecognition = () => {
    if (!subtitleState.isEnabled || !includeAudio) return;
    
    try {
      if (!speechRecognitionRef.current) {
        if (!initializeSpeechRecognition()) return;
      }
      
      if (speechRecognitionRef.current && !subtitleState.isListening) {
        speechRecognitionRef.current.start();
      }
    } catch (error) {
      console.error('ÂêØÂä®ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•:', error);

    }
  };
  
  const stopSpeechRecognition = () => {
    try {
      if (speechRecognitionRef.current) {
        speechRecognitionRef.current.stop();
        speechRecognitionRef.current = null;
      }
      if (recognitionIntervalRef.current) {
        clearInterval(recognitionIntervalRef.current);
        recognitionIntervalRef.current = null;
      }
      setSubtitleState(prev => ({ ...prev, isListening: false }));
    } catch (error) {
      console.error('ÂÅúÊ≠¢ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•:', error);
    }
  };
  
  // Subtitle Export Functions
  const formatTimeForSRT = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
  };
  
  const formatTimeForVTT = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
  };
  
  const generateSRTContent = (): string => {
    if (subtitleState.segments.length === 0) return '';
    
    return subtitleState.segments.map((segment, index) => {
      const startTime = formatTimeForSRT(segment.startTime);
      const endTime = formatTimeForSRT(segment.endTime);
      return `${index + 1}\n${startTime} --> ${endTime}\n${segment.text}\n`;
    }).join('\n');
  };
  
  const generateVTTContent = (): string => {
    if (subtitleState.segments.length === 0) return 'WEBVTT\n\n';
    
    const vttHeader = 'WEBVTT\n\n';
    const vttContent = subtitleState.segments.map((segment, index) => {
      const startTime = formatTimeForVTT(segment.startTime);
      const endTime = formatTimeForVTT(segment.endTime);
      return `${index + 1}\n${startTime} --> ${endTime}\n${segment.text}\n`;
    }).join('\n');
    
    return vttHeader + vttContent;
  };
  
  const downloadSubtitles = (format: 'srt' | 'vtt') => {
    if (subtitleState.segments.length === 0) {

      return;
    }
    
    const content = format === 'srt' ? generateSRTContent() : generateVTTContent();
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    
    const finalTitle = videoTitle.trim() || getDefaultTitle();
    const cleanTitle = finalTitle.replace(/[<>:"/\|?*]/g, '-');
    a.download = `${cleanTitle}.${format}`;
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    

  };
  
  const getShareUrl = (videoId: string) => {
    return `${window.location.origin}/share/${videoId}`;
  };
  
  const copyShareLink = async (videoId: string) => {
    const shareUrl = getShareUrl(videoId);
    try {
      await navigator.clipboard.writeText(shareUrl);

    } catch (error) {
      console.error(RECORDING.copyFailed, error);
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = shareUrl;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);

    }
  };
  
  const shareVideo = async (video: any) => {
    const shareUrl = getShareUrl(video.$id);
    
    if (navigator.share) {
      try {
        await navigator.share({
          title: video.title,
          text: `${RECORDING.watchVideo}: ${video.title}`,
          url: shareUrl,
        });
        // ÂéüÁîüÂàÜ‰∫´ÊàêÂäüÔºå‰∏çÊòæÁ§∫Ê∂àÊÅØ
      } catch (error) {
        // Áî®Êà∑ÂèñÊ∂àÂàÜ‰∫´ÊàñÂÖ∂‰ªñÈîôËØØÔºå‰∏ç‰Ωú‰ªª‰ΩïÊìç‰Ωú
        if (error instanceof Error && error.name !== 'AbortError') {
          console.log('Share cancelled or failed:', error.message);
        }
      }
    } else {
      // ÊµèËßàÂô®‰∏çÊîØÊåÅÂéüÁîüÂàÜ‰∫´ÔºåÊòæÁ§∫ÊèêÁ§∫Ê∂àÊÅØ

    }
  };

  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const screenStreamRef = useRef<MediaStream | null>(null);
  const cameraStreamRef = useRef<MediaStream | null>(null);
  const cameraPreviewRef = useRef<HTMLVideoElement | null>(null);
  
  // Speech recognition refs
  const speechRecognitionRef = useRef<SpeechRecognition | null>(null);
  const recognitionIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const recordingStartTimeRef = useRef<number>(0);

  // ÁõëÂê¨ÊëÑÂÉèÂ§¥ÂºÄÂêØÁä∂ÊÄÅÂèòÂåñ
  useEffect(() => {
    // Âè™Âú®ÁªÑ‰ª∂ÂÆåÂÖ®ÊåÇËΩΩÂêéÊâçÂ§ÑÁêÜÊëÑÂÉèÂ§¥È¢ÑËßà
    if (!isMounted) {
      console.log('Component not fully mounted yet, skipping camera preview');
      return;
    }
    
    console.log('Camera state change:', { includeCamera, isRecording: recordingState.isRecording, isMounted });
    
    if (includeCamera) {
      // ÂºÄÂêØÊëÑÂÉèÂ§¥Êó∂ÂêØÂä®È¢ÑËßàÔºàÂΩïÂà∂Êó∂‰πü‰øùÊåÅÂºÄÂêØÔºâ
      if (!cameraPreviewStream) {
        console.log('Starting camera preview...');
        startCameraPreview();
      } else if (recordingState.isRecording) {
        console.log('Recording in progress, keeping camera picture-in-picture enabled...');
      }
    } else {
      // ÂÖ≥Èó≠ÊëÑÂÉèÂ§¥Êó∂ÂÅúÊ≠¢È¢ÑËßà
      console.log('Stopping camera preview...');
      stopCameraPreview();
    }
  }, [includeCamera, recordingState.isRecording, isMounted]);

  // Ëá™Âä®ÂÖ≥Èó≠ÊëÑÂÉèÂ§¥ÂΩìÈÄâÊã©‰∏çÊîØÊåÅÁöÑÂΩïÂà∂Ê∫êÊó∂
  useEffect(() => {
    if ((screenSource === 'window' || screenSource === 'browser') && 
        source !== 'camera-only' && 
        includeCamera) {
      console.log(`Auto-closing camera when ${screenSource === 'window' ? 'application window' : 'browser tab'} is selected`);
      setIncludeCamera(false);
    }
  }, [screenSource, source, includeCamera]);

  // ÁªÑ‰ª∂ÊåÇËΩΩÁä∂ÊÄÅÁÆ°ÁêÜ
  useEffect(() => {
    setIsMounted(true);
    
    // ‰∏çÈúÄË¶Å‰ªé localStorage ÊÅ¢Â§çÁä∂ÊÄÅÔºåÂõ†‰∏∫‰∏çÂÜçÂ≠òÂÇ® Blob Êï∞ÊçÆ
    // ÁôªÂΩï‰∏ç‰ºöÂà∑Êñ∞È°µÈù¢ÔºåÊâÄÊúâÁä∂ÊÄÅÈÉΩÂú®ÂÜÖÂ≠ò‰∏≠‰øùÊåÅ
    console.log('Component initialization, using default state');
    
    return () => {
      setIsMounted(false);
      stopCameraPreview();
    };
  }, []);

  // Áä∂ÊÄÅÂèòÂåñÁõëÊéß - Áî®‰∫éË∞ÉËØïFirefoxÈóÆÈ¢ò
  useEffect(() => {
    console.log('=== RecordingState Change ===', {
      isRecording: recordingState.isRecording,
      isPaused: recordingState.isPaused,
      hasBlob: !!recordingState.recordedBlob,
      blobSize: recordingState.recordedBlob?.size || 0,
      duration: recordingState.duration,
      timestamp: new Date().toISOString()
    });
    
    if (recordingState.recordedBlob && !recordingState.isRecording) {
      console.log('üéÜ Recording completed! Preview page should be displayed.');
      console.log('Blob details:', {
        size: recordingState.recordedBlob.size,
        type: recordingState.recordedBlob.type,
        sizeInKB: Math.round(recordingState.recordedBlob.size / 1024)
      });
      
      // Ê£ÄÊü•È¢ÑËßàÈ°µÊòæÁ§∫Êù°‰ª∂
      const shouldShowPreview = recordingState.recordedBlob && !uploadedVideo;
      console.log('Preview page display conditions:', {
        hasBlob: !!recordingState.recordedBlob,
        noUploadedVideo: !uploadedVideo,
        shouldShow: shouldShowPreview
      });
    }
  }, [recordingState, uploadedVideo]);

  const getQualityConstraints = (quality: RecordingQuality) => {
    return quality === '1080p' 
      ? { width: 1920, height: 1080 }
      : { width: 1280, height: 720 };
  };

  const startTimer = () => {
    timerRef.current = setInterval(() => {
      setRecordingState(prev => {
        const newDuration = prev.duration + 1;
        
        // Check if time limit is enabled
        if (recordingConfig.enableTimeLimit) {
          // Show warning when approaching time limit
          if (newDuration >= recordingConfig.timeWarningThreshold && !showTimeWarning) {
            setShowTimeWarning(true);
            setIsNearTimeLimit(true);

          }
          
          // Stop recording when time limit is reached
          if (newDuration >= recordingConfig.maxDurationSeconds) {
            stopRecording();

            return prev; // Don't update duration as recording is stopping
          }
        }
        
        return { ...prev, duration: newDuration };
      });
    }, 1000);
  };

  const stopTimer = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
  };

  const formatDuration = (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // Ê£ÄÊµãÁîª‰∏≠ÁîªAPIÊîØÊåÅÊÉÖÂÜµ
  // Unified browser detection function


  const detectPiPSupport = useCallback(() => {
    const browser = detectBrowserFromLib();
    
    // ÂØπFirefoxÂÅöÁâπÊÆäÂ§ÑÁêÜ - FirefoxÂèØËÉΩ‰∏çÊèê‰æõdocument.pictureInPictureEnabled
    let supported = false;
    
    if (browser.isFirefox) {
      // Firefox: FirefoxÊúâÂéüÁîüÁîª‰∏≠ÁîªÊåâÈíÆÔºå‰∏ç‰æùËµñJS API
      // FirefoxÁöÑÁîª‰∏≠ÁîªÊòØÈÄöËøáËßÜÈ¢ëÊéß‰ª∂ÂÆûÁé∞ÔºåËÄå‰∏çÊòØÈÄöËøárequestPictureInPicture API
      const firefoxVersionMatch = navigator.userAgent.match(/Firefox\/(\d+)/);
      const firefoxVersion = firefoxVersionMatch ? parseInt(firefoxVersionMatch[1]) : 0;
      
      // Firefox 71+ÊúâÂéüÁîüÁîª‰∏≠ÁîªÊîØÊåÅÔºå‰ΩÜÈúÄË¶ÅÈÄöËøáËßÜÈ¢ëÊéß‰ª∂
      supported = firefoxVersion >= 71;
      

    } else {
      // ÂÖ∂‰ªñÊµèËßàÂô®‰ΩøÁî®Â∏∏ËßÑÊ£ÄÊü•
      const testVideo = document.createElement('video');
      const hasPiPEnabled = document.pictureInPictureEnabled !== false;
      const hasRequestMethod = 'requestPictureInPicture' in testVideo;
      supported = hasPiPEnabled && hasRequestMethod;
    }
    

    
    return {
      supported,
      canAutoStart: browser.isChrome, // Âè™ÊúâChromeÊîØÊåÅËá™Âä®ÂêØÂä®
      needsUserInteraction: browser.isSafari || browser.isFirefox,
      browser: browser.name
    };
  }, []);
  
  // ÂêØÂä®ÊëÑÂÉèÂ§¥È¢ÑËßà - ÈáçÂÜôÁîª‰∏≠ÁîªÈÄªËæë
  const startCameraPreview = async () => {
    console.log('Starting camera preview initialization...');
    
    try {
      // Ê£ÄÊü•ÊµèËßàÂô®ÊîØÊåÅ
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('ÊµèËßàÂô®‰∏çÊîØÊåÅÊëÑÂÉèÂ§¥ÂäüËÉΩ');
      }

      console.log('Requesting camera permission...');
      
      // ‰ΩøÁî®Â∞ùËØï-ÈôçÁ∫ßÁ≠ñÁï•Êù•Ëé∑ÂèñÊëÑÂÉèÂ§¥ÊµÅ
      let stream: MediaStream;
      
      // Á¨¨‰∏ÄÊ¨°Â∞ùËØïÔºöÁêÜÊÉ≥ËÆæÁΩÆ
      try {
        const idealConstraints: MediaStreamConstraints = {
          video: {
            width: { ideal: 320 },
            height: { ideal: 240 },
            facingMode: 'user'
          },
          audio: false
        };
        console.log('Trying ideal settings:', idealConstraints);
        stream = await navigator.mediaDevices.getUserMedia(idealConstraints);
      } catch (firstError) {
        console.warn('ÁêÜÊÉ≥ËÆæÁΩÆÂ§±Ë¥•ÔºåÂ∞ùËØïÂü∫Êú¨ËÆæÁΩÆ:', firstError);
        
        // Á¨¨‰∫åÊ¨°Â∞ùËØïÔºöÁßªÈô§Â∞∫ÂØ∏Á∫¶Êùü
        try {
          const basicConstraints: MediaStreamConstraints = {
            video: {
              facingMode: 'user'
            },
            audio: false
          };
          console.log('Trying basic settings:', basicConstraints);
          stream = await navigator.mediaDevices.getUserMedia(basicConstraints);
        } catch (secondError) {
          console.warn('Âü∫Êú¨ËÆæÁΩÆÂ§±Ë¥•ÔºåÂ∞ùËØïÊúÄÁÆÄÂçïËÆæÁΩÆ:', secondError);
          
          // Á¨¨‰∏âÊ¨°Â∞ùËØïÔºöÊúÄÁÆÄÂçïËÆæÁΩÆ
          const minimalConstraints: MediaStreamConstraints = {
            video: true,
            audio: false
          };
          console.log('Trying minimal settings:', minimalConstraints);
          stream = await navigator.mediaDevices.getUserMedia(minimalConstraints);
        }
      }
      
      console.log('Camera stream obtained successfully:', {
        id: stream.id,
        active: stream.active,
        videoTracks: stream.getVideoTracks().length
      });
      
      // Ê£ÄÊü•ËßÜÈ¢ëËΩ®ÈÅì
      const videoTracks = stream.getVideoTracks();
      if (videoTracks.length === 0) {
        throw new Error('Ê≤°ÊúâÊâæÂà∞ÂèØÁî®ÁöÑÊëÑÂÉèÂ§¥');
      }
      
      setCameraPreviewStream(stream);
      
      // Ê£ÄÊµãÁîª‰∏≠ÁîªÊîØÊåÅ
      const pipSupport = detectPiPSupport();
      
      // ËÆæÁΩÆËßÜÈ¢ëÊµÅÂà∞ÂÖÉÁ¥†
      const setupVideoElement = (retryCount = 0) => {
        const maxRetries = 10;
        
        if (cameraPreviewRef.current) {
          console.log('Setting up video element...');
          cameraPreviewRef.current.srcObject = stream;
          
          // Ê†πÊçÆÁîª‰∏≠ÁîªÊîØÊåÅÊÉÖÂÜµÂÜ≥ÂÆöÊòæÁ§∫Á≠ñÁï•
          if (!pipSupport.supported) {
            // ‰∏çÊîØÊåÅÁîª‰∏≠ÁîªÔºåÊòæÁ§∫ÊôÆÈÄöËßÜÈ¢ëÈ¢ÑËßà
            console.log('Browser does not support picture-in-picture, showing normal video preview');

          } else if (pipSupport.canAutoStart) {
            // Chrome - Â∞ùËØïËá™Âä®ÂêØÂä®Áîª‰∏≠Áîª
            cameraPreviewRef.current.onloadedmetadata = async () => {
              console.log('Chrome detected, trying to auto-start picture-in-picture');
              try {
                if (!document.pictureInPictureElement && !isPiPRequesting) {
                  setIsPiPRequestingWithTimeout(true);
                  await cameraPreviewRef.current!.requestPictureInPicture();
                  console.log('Chrome picture-in-picture auto-start successful');

                }
              } catch (error: any) {
                console.log('Chrome auto-start failed, falling back to manual mode:', error.message);

              } finally {
                setIsPiPRequestingWithTimeout(false);
              }
            };
          } else {
            // Safari/Firefox - ÊòæÁ§∫ÂºïÂØº‰ø°ÊÅØ
            console.log(`${pipSupport.browser} detected, requires manual picture-in-picture activation`);

          }
          
          // ËÆæÁΩÆÈÄöÁî®‰∫ã‰ª∂ÁõëÂê¨Âô®
          cameraPreviewRef.current.onenterpictureinpicture = () => {
            console.log('Entering picture-in-picture mode');
            setIsPiPRequestingWithTimeout(false);
          };
          
          cameraPreviewRef.current.onleavepictureinpicture = () => {
            console.log('Exiting picture-in-picture mode');
            setIsPiPRequestingWithTimeout(false);
          };
          
          cameraPreviewRef.current.onerror = (e) => {
            console.error('ËßÜÈ¢ëÂÖÉÁ¥†ÈîôËØØ:', e);
          };
          
          // Êí≠ÊîæËßÜÈ¢ë
          cameraPreviewRef.current.play().then(() => {
            console.log('Video playback successful');
          }).catch((playError) => {
            console.error('ËßÜÈ¢ëÊí≠ÊîæÂ§±Ë¥•:', playError);
          });
          
        } else if (retryCount < maxRetries) {
          console.log(`Video element not rendered yet, retrying later (${retryCount + 1}/${maxRetries})...`);
          setTimeout(() => {
            setupVideoElement(retryCount + 1);
          }, 200);
        } else {
          console.error('ËææÂà∞ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞ÔºåÊîæÂºÉËÆæÁΩÆËßÜÈ¢ëÂÖÉÁ¥†');

        }
      };
      
      setupVideoElement();
      
    } catch (error: any) {
      console.error('Camera preview startup failed:', {
        name: error.name,
        message: error.message,
        constraint: error.constraint
      });
      
      let errorMessage = 'Unable to start camera preview';
      if (error.name === 'NotAllowedError') {
        errorMessage = 'Camera permission denied. Please allow camera access';
      } else if (error.name === 'NotFoundError') {
        errorMessage = 'Camera device not found';
      } else if (error.name === 'NotReadableError') {
        errorMessage = 'Camera is being used by another application';
      } else if (error.name === 'OverconstrainedError') {
        errorMessage = `Camera does not support requested settings (${error.constraint}). Automatically downgraded, please retry`;
      } else if (error.name === 'TypeError') {
        errorMessage = 'Browser does not support camera functionality or lacks necessary permissions';
      }
      

    }
  };

  // ÊâãÂä®ÂêØÂä®Áîª‰∏≠ÁîªÊ®°Âºè - ÈáçÂÜôÊîØÊåÅÊâÄÊúâÊµèËßàÂô®
  const startPictureInPictureManually = async () => {
    if (!cameraPreviewRef.current || !cameraPreviewStream) {

      return;
    }

    if (document.pictureInPictureElement) {

      return;
    }

    if (isPiPRequesting) {

      return;
    }
    
    // Ê£ÄÊµãÊµèËßàÂô®ÂíåÁîª‰∏≠ÁîªÊîØÊåÅ
    const pipSupport = detectPiPSupport();
    
    if (!pipSupport.supported) {

      return;
    }
    
    // FirefoxÁâπÂà´Ê£ÄÊü• - Á°Æ‰øùÂèØÁî®
    if (pipSupport.browser === 'Firefox') {
      // Ê£ÄÊü•FirefoxÁâàÊú¨ÂíåËÆæÁΩÆ
      const userAgent = navigator.userAgent;
      const firefoxVersionMatch = userAgent.match(/Firefox\/(\d+)/);
      const firefoxVersion = firefoxVersionMatch ? parseInt(firefoxVersionMatch[1]) : 0;
      
      if (firefoxVersion < 71) {

        return;
      }
      
      if (!document.pictureInPictureEnabled) {

        return;
      }
    }
    
    // Á°Æ‰øùvideoÂÖÉÁ¥†ÊúârequestPictureInPictureÊñπÊ≥ï
    if (typeof cameraPreviewRef.current.requestPictureInPicture !== 'function') {
      console.error('videoÂÖÉÁ¥†Áº∫Â∞ërequestPictureInPictureÊñπÊ≥ï');
      if (pipSupport.browser === 'Firefox') {

      } else {

      }
      return;
    }

    console.log(`Starting manual picture-in-picture activation for ${pipSupport.browser} browser`);
    setIsPiPRequestingWithTimeout(true);
    
    try {
      await cameraPreviewRef.current.requestPictureInPicture();
      console.log('Manual picture-in-picture activation successful');

    } catch (error: any) {
      console.error('ÊâãÂä®ÂêØÂä®Áîª‰∏≠ÁîªÂ§±Ë¥•:', error);
      
      // ÊµèËßàÂô®ÁâπÂÆöÈîôËØØÂ§ÑÁêÜ
      if (error.name === 'NotAllowedError') {
        if (pipSupport.browser === 'Safari') {

        } else if (pipSupport.browser === 'Firefox') {

        } else {

        }
      } else if (error.name === 'InvalidStateError') {
        if (pipSupport.browser === 'Firefox') {

        } else {

        }
      } else if (error.message.includes('processing')) {

      } else if (error.name === 'NotSupportedError') {

      } else {

      }
    } finally {
      setIsPiPRequestingWithTimeout(false);
    }
  };

  // ÂÅúÊ≠¢ÊëÑÂÉèÂ§¥È¢ÑËßà - ÈÄÄÂá∫Áîª‰∏≠ÁîªÊ®°Âºè
  const stopCameraPreview = async () => {
    console.log('Stopping camera picture-in-picture preview...');
    
    try {
      // ÊâÄÊúâÊ®°ÂºèÈÉΩÂ∞ùËØïÈÄÄÂá∫Áîª‰∏≠ÁîªÊ®°Âºè
      if (document.pictureInPictureElement) {
        console.log('Exiting picture-in-picture mode...');
        await document.exitPictureInPicture();
        console.log('Picture-in-picture mode exit successful');
      }
    } catch (error) {
      console.warn('ÈÄÄÂá∫Áîª‰∏≠ÁîªÊ®°ÂºèÂ§±Ë¥•:', error);
      // ‰∏çÈòªÂ°ûÂêéÁª≠Ê∏ÖÁêÜÊìç‰Ωú
    }
    
    if (cameraPreviewStream) {
      console.log('Stopping camera stream...');
      cameraPreviewStream.getTracks().forEach(track => {
        console.log('Stopping track:', track.label);
        track.stop();
      });
      setCameraPreviewStream(null);
    }
    
    if (cameraPreviewRef.current) {
      console.log('Cleaning up picture-in-picture video element...');
      // ÊöÇÂÅúËßÜÈ¢ë
      cameraPreviewRef.current.pause();
      // Ê∏ÖÁ©∫ËßÜÈ¢ëÊ∫ê
      cameraPreviewRef.current.srcObject = null;
      // ÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨Âô®
      cameraPreviewRef.current.onloadedmetadata = null;
      cameraPreviewRef.current.onenterpictureinpicture = null;
      cameraPreviewRef.current.onleavepictureinpicture = null;
      cameraPreviewRef.current.onerror = null;
    }
    

    
    console.log('Camera picture-in-picture preview stop completed');
  };

  const getScreenStream = async (): Promise<MediaStream> => {
    const constraints = getQualityConstraints(quality);
    const browser = detectBrowserFromLib();
    
    // Configure display media constraints based on screen source type
    const displayConstraints: any = {
      video: {
        ...constraints,
        frameRate: { ideal: 30, max: 60 }
      },
      audio: includeAudio // ÊîØÊåÅÁã¨Á´ãÁöÑÈü≥È¢ëÊéßÂà∂
    };
    
    console.log('Screen audio status:', includeAudio ? 'enabled' : 'disabled');
    console.log('Browser information:', {
      name: browser.name,
      supportsDisplaySurface: browser.supportsDisplaySurface
    });

    // Add source-specific constraints only for browsers that support displaySurface
    if (browser.supportsDisplaySurface && 'getDisplayMedia' in navigator.mediaDevices) {
      if (screenSource === 'window') {
        console.log('Requesting window capture with displaySurface constraint...');
        displayConstraints.video = {
          ...displayConstraints.video,
          // @ts-ignore - Chrome/Edge experimental API
          displaySurface: 'window'
        };
      } else if (screenSource === 'browser') {
        console.log('Requesting browser tab capture with displaySurface constraint...');
        displayConstraints.video = {
          ...displayConstraints.video,
          // @ts-ignore - Chrome/Edge experimental API
          displaySurface: 'browser'
        };
      } else {
        console.log('Requesting monitor capture with displaySurface constraint...');
        displayConstraints.video = {
          ...displayConstraints.video,
          // @ts-ignore - Chrome/Edge experimental API
          displaySurface: 'monitor'
        };
      }
    } else {
      // Safari/Firefox: Use standard getDisplayMedia without displaySurface constraints
      console.log(`${browser.name} detected: Using standard getDisplayMedia without displaySurface constraints`);
      if (browser.isSafari || browser.isFirefox) {
        console.log(`Safari/Firefox will show native source selection dialog with all available options`);
      }
    }
    
    console.log('Display constraints:', displayConstraints);
    
    try {
      const stream = await navigator.mediaDevices.getDisplayMedia(displayConstraints);
      
      // Log what was actually captured
      const videoTrack = stream.getVideoTracks()[0];
      if (videoTrack) {
        const settings = videoTrack.getSettings();
        console.log('Actual capture settings:', {
          displaySurface: settings.displaySurface,
          width: settings.width,
          height: settings.height,
          frameRate: settings.frameRate
        });
        
        // Provide user feedback about what's being captured
        const surfaceType = settings.displaySurface;
        if (surfaceType) {
          const surfaceMap: Record<string, string> = {
            monitor: 'Entire Screen',
            window: 'Application Window', 
            browser: 'Browser Tab'
          };
          console.log(`Actual capture type: ${surfaceMap[surfaceType] || surfaceType}`);
          
          // Show user what's actually being captured
          const actualType = surfaceMap[surfaceType] || surfaceType;
          const expectedType = surfaceMap[screenSource] || screenSource;
          
          if (surfaceType !== screenSource) {
            console.warn(`User selected: ${expectedType}, Actually captured: ${actualType}`);
            // Don't show alert during recording, just log for debugging
          }
        }
      }
      
      return stream;
    } catch (error) {
      console.error('getDisplayMedia error:', error);
      throw error;
    }
  };

  const getCameraStream = async (audioOnly: boolean = false): Promise<MediaStream> => {
    const constraints = getQualityConstraints(quality);
    
    // Â¶ÇÊûúÂè™ÈúÄË¶ÅÈü≥È¢ëÔºåÂàô‰∏çËØ∑Ê±ÇËßÜÈ¢ëÊµÅ
    return await navigator.mediaDevices.getUserMedia({
      video: audioOnly ? false : {
        ...constraints,
        facingMode: 'user'
      },
      audio: includeAudio // Áã¨Á´ãÊéßÂà∂Èü≥È¢ë
    });
  };
  
  // Âè™Ëé∑ÂèñÈü≥È¢ëÊµÅÔºàÂΩì‰∏çÈúÄË¶ÅÊëÑÂÉèÂ§¥ËßÜÈ¢ë‰ΩÜÈúÄË¶ÅÈü≥È¢ëÊó∂Ôºâ
  const getAudioOnlyStream = async (): Promise<MediaStream | null> => {
    if (!includeAudio) return null; // Â¶ÇÊûú‰∏çÂåÖÂê´Èü≥È¢ëÔºåÁõ¥Êé•ËøîÂõûnull
    
    try {
      console.log('Getting standalone audio stream...');
      const audioStream = await navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true
      });
      
      console.log('Audio stream acquired successfully:', {
        id: audioStream.id,
        audioTracks: audioStream.getAudioTracks().length
      });
      
      return audioStream;
    } catch (error) {
      console.error('Audio stream acquisition failed:', error);
      return null;
    }
  };

  const combineStreams = (streams: MediaStream[]): MediaStream => {
    console.log('Combining streams:', streams.map(s => ({
      id: s.id,
      videoTracks: s.getVideoTracks().length,
      audioTracks: s.getAudioTracks().length
    })));
    
    const combinedStream = new MediaStream();
    const isScreenRecording = source === 'screen' || source === 'both';
    
    streams.forEach((stream, index) => {
      const videoTracks = stream.getVideoTracks();
      const audioTracks = stream.getAudioTracks();
      
      console.log(`Stream ${index}:`, {
        videoTracks: videoTracks.length,
        audioTracks: audioTracks.length,
        videoEnabled: videoTracks.map(t => t.enabled),
        audioEnabled: audioTracks.map(t => t.enabled)
      });
      
      // Âú®Â±èÂπïÂΩïÂà∂Ê®°Âºè‰∏ãÔºåÂè™‰ΩøÁî®Á¨¨‰∏Ä‰∏™ÊµÅÔºàÂ±èÂπïÊµÅÔºâÁöÑËßÜÈ¢ë
      const shouldAddVideo = !isScreenRecording || index === 0;
      
      // Add video tracks (screen video only in screen recording mode)
      if (shouldAddVideo) {
        videoTracks.forEach(track => {
          if (track.readyState === 'live') {
            combinedStream.addTrack(track);
            console.log(`Added video track from stream ${index}:`, track.label);
          }
        });
      } else {
        console.log(`Skipped video tracks from stream ${index} (using screen video with PiP)`);
      }
      
      // Add all audio tracks from all streams
      audioTracks.forEach(track => {
        if (track.readyState === 'live') {
          combinedStream.addTrack(track);
          console.log(`Added audio track from stream ${index}:`, track.label);
        }
      });
    });
    
    console.log('Combined stream tracks:', {
      videoTracks: combinedStream.getVideoTracks().length,
      audioTracks: combinedStream.getAudioTracks().length,
      totalTracks: combinedStream.getTracks().length
    });
    
    return combinedStream;
  };

  const startRecording = async () => {
    try {
      // Ê∏ÖÈô§‰πãÂâçÁöÑÂΩïÂà∂ÈîôËØØÁä∂ÊÄÅ
      setRecordingError(null);
      
      // ÂΩïÂà∂Êó∂‰øùÊåÅÁîª‰∏≠ÁîªÂºÄÂêØÔºåÂ±èÂπïÂΩïÂà∂‰ºöÂåÖÂê´Áîª‰∏≠ÁîªÂÜÖÂÆπ
      console.log('Starting recording, keeping camera picture-in-picture enabled...');
      
      chunksRef.current = [];
      const streams: MediaStream[] = [];

      // Request permissions and get streams based on source
      if (source === 'screen' || source === 'both') {
        const sourceNames: Record<string, string> = {
          monitor: 'Entire Screen',
          window: 'Application Window',
          browser: 'Browser Tab'
        };
        
        // Check Permissions Policy before attempting screen capture
        const policyCheck = checkPermissionsPolicy();
        console.log('Permissions Policy check:', policyCheck);
        
        if (policyCheck.supported && !policyCheck.allowed) {
          const errorMessage = 'Screen recording is blocked by permissions policy. Please ensure this page is opened in a new tab, not in an iframe or embedded environment.';
          console.error(errorMessage);
          setRecordingError(errorMessage);
          return;
        }
        
        console.log(`Requesting screen recording permission (${sourceNames[screenSource]})...`);
        
        try {
          const screenStream = await getScreenStream();
          screenStreamRef.current = screenStream;
          streams.push(screenStream);
          console.log(`Screen recording permission granted - target: ${sourceNames[screenSource]}`);
          // Keep browser compatibility logic but remove user feedback
        } catch (error: any) {
          console.error('Screen recording permission denied:', error);
          if (error.name === 'NotAllowedError') {
            const errorMessage = 'Â±èÂπïÂΩïÂà∂ÊùÉÈôêË¢´ÊãíÁªù„ÄÇËØ∑Âú®ÊµèËßàÂô®ÂºπÁ™ó‰∏≠ÂÖÅËÆ∏Â±èÂπïÂÖ±‰∫´ÔºåÊàñÊ£ÄÊü•ÊµèËßàÂô®ËÆæÁΩÆ‰∏≠ÁöÑÂ™í‰ΩìÊùÉÈôê„ÄÇ';
            console.error(errorMessage);
            setRecordingError(errorMessage);
            return;
          } else if (error.message && error.message.includes('display-capture')) {
            const errorMessage = 'ÊµèËßàÂô®‰∏çÊîØÊåÅÂ±èÂπïÂΩïÂà∂ÊàñË¢´ÂÆâÂÖ®Á≠ñÁï•ÈòªÊ≠¢„ÄÇËØ∑Â∞ùËØïÂú®Êñ∞Ê†áÁ≠æÈ°µ‰∏≠ÊâìÂºÄÊ≠§È°µÈù¢ÔºåÊàñÊ£ÄÊü•ÊµèËßàÂô®ÁöÑÂ™í‰ΩìÊùÉÈôêËÆæÁΩÆ„ÄÇ';
            console.error(errorMessage);
            setRecordingError(errorMessage);
            return;
          }
          throw error;
        }
      }

      // ‰ªÖÂΩïÂà∂ÊëÑÂÉèÂ§¥ÁöÑÊÉÖÂÜµÊâçÈúÄË¶ÅÊëÑÂÉèÂ§¥ÊµÅ
      if (source === 'camera-only') {
        console.log('Request camera permission for camera-only recording...');
        try {
          const cameraStream = await getCameraStream();
          cameraStreamRef.current = cameraStream;
          streams.push(cameraStream);
          console.log('Camera permission granted:', {
            videoTracks: cameraStream.getVideoTracks().length,
            audioTracks: cameraStream.getAudioTracks().length,
            active: cameraStream.active
          });
          
          // Verify camera tracks are active
          cameraStream.getVideoTracks().forEach(track => {
            console.log('Camera video track:', {
              id: track.id,
              label: track.label,
              enabled: track.enabled,
              readyState: track.readyState
            });
          });
        } catch (error: any) {
          console.error('Camera permission denied:', error);
          if (error.name === 'NotAllowedError') {
            const errorMessage = 'ÊëÑÂÉèÂ§¥ËÆøÈóÆÊùÉÈôêË¢´ÊãíÁªù„ÄÇËØ∑Âú®ÊµèËßàÂô®ÂºπÁ™ó‰∏≠ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ËÆøÈóÆÔºåÊàñÂú®ÊµèËßàÂô®ËÆæÁΩÆ‰∏≠Ê£ÄÊü•Â™í‰ΩìÊùÉÈôê„ÄÇ';
            console.error(errorMessage);
            setRecordingError(errorMessage);
            return;
          } else if (error.name === 'NotFoundError') {
            const errorMessage = 'Êú™ÊâæÂà∞ÂèØÁî®ÁöÑÊëÑÂÉèÂ§¥ËÆæÂ§á„ÄÇËØ∑Á°Æ‰øùÊëÑÂÉèÂ§¥Â∑≤ËøûÊé•Âπ∂‰∏îÊ≤°ÊúâË¢´ÂÖ∂‰ªñÂ∫îÁî®Á®ãÂ∫èÂç†Áî®„ÄÇ';
            console.error(errorMessage);
            setRecordingError(errorMessage);
            return;
          }
          throw error;
        }
      }
      
      // ÂØπ‰∫éÂ±èÂπïÂΩïÂà∂Ê®°ÂºèÔºåÊ†πÊçÆÊëÑÂÉèÂ§¥ÂºÄÂêØÁä∂ÊÄÅÂÜ≥ÂÆö‰ΩøÁî®Âì™ÁßçÊ®°ÂºèËé∑ÂèñÈü≥È¢ë
      if ((source === 'screen' || source === 'both')) {
        if (includeCamera) {
          // Â¶ÇÊûúÂºÄÂêØ‰∫ÜÊëÑÂÉèÂ§¥Ôºå‰ΩøÁî®ÊëÑÂÉèÂ§¥ÊµÅËé∑ÂèñÈü≥È¢ëÂíåÁîª‰∏≠ÁîªËßÜÈ¢ë
          console.log('Adding camera stream for audio (picture-in-picture provides video)');
          try {
            const cameraStream = await getCameraStream();
            cameraStreamRef.current = cameraStream;
            streams.push(cameraStream);
            console.log('Camera stream added successfully, includes audio tracks:', {
              videoTracks: cameraStream.getVideoTracks().length,
              audioTracks: cameraStream.getAudioTracks().length,
              active: cameraStream.active
            });
          } catch (error: any) {
            console.error('ÊëÑÂÉèÂ§¥Èü≥È¢ëËé∑ÂèñÂ§±Ë¥•:', error);
            console.warn('Â∞ÜÁªßÁª≠Â±èÂπïÂΩïÂà∂Ôºå‰ΩÜÊ≤°ÊúâÊëÑÂÉèÂ§¥Èü≥È¢ë');
          }
        } else if (includeAudio) {
          // Â¶ÇÊûúÂÖ≥Èó≠‰∫ÜÊëÑÂÉèÂ§¥‰ΩÜÂºÄÂêØ‰∫ÜÈü≥È¢ëÔºåËé∑ÂèñÁã¨Á´ãÈü≥È¢ëÊµÅ
          console.log('Getting standalone audio stream...');
          try {
            const audioStream = await getAudioOnlyStream();
            if (audioStream) {
              streams.push(audioStream);
              console.log('Independent audio stream added successfully:', {
                audioTracks: audioStream.getAudioTracks().length
              });
            }
          } catch (error) {
            console.error('Áã¨Á´ãÈü≥È¢ëËé∑ÂèñÂ§±Ë¥•:', error);
          }
        }
      }

      if (streams.length === 0) {
        throw new Error('No streams available for recording');
      }

      let finalStream: MediaStream;
      
      if (streams.length === 1) {
        finalStream = streams[0];
        console.log('Using single stream for recording');
      } else {
        finalStream = combineStreams(streams);
        console.log('Using combined stream for recording');
      }
      
      // Verify final stream has tracks
      console.log('Final stream for recording:', {
        id: finalStream.id,
        videoTracks: finalStream.getVideoTracks().length,
        audioTracks: finalStream.getAudioTracks().length,
        active: finalStream.active
      });
      
      const browser = detectBrowserFromLib();
      
      // ÊµèËßàÂô®ÂÖºÂÆπÊÄßÂ¢ûÂº∫
      const isFirefoxRecording = browser.isFirefox;
      const isSafariRecording = browser.isSafari;

      let options: MediaRecorderOptions = {};
      
      if (browser.isFirefox) {
        console.log('ü§ä Firefox detected, using optimized settings...');
        
        // Firefox ÂÖºÂÆπÊÄßÊ£ÄÊü•
        const firefoxSupportedTypes = [
          'video/webm;codecs=vp8',
          'video/webm', 
          'video/mp4',
          ''
        ];
        
        for (const mimeType of firefoxSupportedTypes) {
          const isSupported = mimeType === '' || MediaRecorder.isTypeSupported(mimeType);
          console.log(`Firefox checking MIME type: ${mimeType || 'default'} - ${isSupported ? 'supported' : 'not supported'}`);
          
          if (isSupported) {
            if (mimeType) {
              options.mimeType = mimeType;
            } else {
              // Use default webm for Firefox when empty mimeType is supported
              options.mimeType = 'video/webm';
            }
            break;
          }
        }
        
        // Firefox ‰ºòÂåñÂèÇÊï∞
        options.videoBitsPerSecond = 1000000; // 1Mbps Èôç‰ΩéÁ†ÅÁéá‰ª•ÊèêÈ´òÂÖºÂÆπÊÄß
        if (includeAudio) {
          options.audioBitsPerSecond = 64000; // 64kbps
        }
      } else if (isSafariRecording) {
        console.log('üçé Safari detected, using Safari compatibility settings...');
        
        // Safari ÂÖºÂÆπÊÄßÊ†ºÂºè‰ºòÂÖàÁ∫ß - ÈÅøÂÖçVP9
        const safariSupportedTypes = [
          'video/mp4',
          'video/webm;codecs=vp8,opus',
          'video/webm;codecs=vp8', 
          'video/webm',
          ''
        ];
        
        for (const mimeType of safariSupportedTypes) {
          const isSupported = mimeType === '' || MediaRecorder.isTypeSupported(mimeType);
          console.log(`Safari checking MIME type: ${mimeType || 'default'} - ${isSupported ? 'supported' : 'not supported'}`);
          
          if (isSupported) {
            if (mimeType) {
              options.mimeType = mimeType;
            } else {
              options.mimeType = 'video/mp4';
            }
            break;
          }
        }
        
        // Safari ‰ºòÂåñÂèÇÊï∞ - Èôç‰ΩéÁ†ÅÁéá‰ª•ÊèêÈ´òÂÖºÂÆπÊÄß
        options.videoBitsPerSecond = quality === '1080p' ? 3000000 : 1500000;
        if (includeAudio) {
          options.audioBitsPerSecond = 128000; // Safari Èü≥È¢ëÁºñÁ†Å‰ºòÂåñ

        }
      } else {
        // Chrome, Edge Á≠âÂÖ∂‰ªñÊµèËßàÂô®‰ΩøÁî®È´òË¥®ÈáèËÆæÁΩÆ
        console.log(`üåê Other browser (${browser.name}) detected, using standard settings...`);
        
        options = {
          mimeType: 'video/webm;codecs=vp9,opus',
          videoBitsPerSecond: quality === '1080p' ? 5000000 : 2500000
        };
        
        // Fallback for browsers that don't support VP9
        if (options.mimeType && !MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = 'video/webm;codecs=vp8,opus';
        }
        
        // Final fallback
        if (options.mimeType && !MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = 'video/webm';
        }
      }
      
      console.log('üé• MediaRecorder configuration:', {
        options,
        browserName: browser.name,
        browser: browser.name,
        isFirefox: browser.isFirefox,
        isSafari: browser.isSafari,
        streamActive: finalStream.active,
        videoTracks: finalStream.getVideoTracks().length,
        audioTracks: finalStream.getAudioTracks().length
      });

      mediaRecorderRef.current = new MediaRecorder(finalStream, options);

      // Â¢ûÂº∫ÁöÑÊï∞ÊçÆÊî∂ÈõÜ‰∫ã‰ª∂
      mediaRecorderRef.current.ondataavailable = (event) => {
        const timestamp = new Date().toISOString();
        console.log(`=== Data available event [${timestamp}] ===`, { 
          size: event.data.size, 
          type: event.data.type,
          browser: isFirefoxRecording ? 'Firefox' : isSafariRecording ? 'Safari' : 'Other'
        });
        
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
          const totalSize = chunksRef.current.reduce((sum, chunk) => sum + chunk.size, 0);
          
          console.log('‚úÖ Successfully collected data chunk:', {
            currentSize: event.data.size,
            totalChunks: chunksRef.current.length,
            totalSizeKB: Math.round(totalSize / 1024),
            isFirefox: isFirefoxRecording,
            isSafari: isSafariRecording,
            browser: browser.name
          });
          
          if (browser.isFirefox) {
            console.log('ü§ä Firefox data collection progress:', {
              chunkIndex: chunksRef.current.length,
              chunkType: event.data.type,
              chunkSize: event.data.size,
              totalAccumulated: totalSize,
              allSizes: chunksRef.current.map(c => c.size)
            });
          }
        } else {
          console.error('‚ùå Êî∂Âà∞Á©∫Êï∞ÊçÆÂùóÔºÅËøôÊòØ‰∏Ä‰∏™‰∏•ÈáçÈóÆÈ¢ò„ÄÇ');
          
          if (browser.isFirefox) {
            console.error('ü§ä Firefox Ê£ÄÊµãÂà∞Á©∫Êï∞ÊçÆÂùóÔºåÂèØËÉΩÂéüÂõ†:');
            console.error('1. Â™í‰ΩìÊµÅ‰∏çÊ¥ªË∑ÉÊàñÂ∑≤ÂÅúÊ≠¢');
            console.error('2. ÁºñÁ†ÅÂô®‰∏çÊîØÊåÅÂΩìÂâçÊ†ºÂºè');
            console.error('3. Firefox ÁâàÊú¨ÂÖºÂÆπÊÄßÈóÆÈ¢ò');
            
            // Ê£ÄÊü•Â™í‰ΩìÊµÅÁä∂ÊÄÅ
            console.log('Firefox media stream status check:', {
              streamActive: finalStream.active,
              videoTracks: finalStream.getVideoTracks().map(t => ({ label: t.label, enabled: t.enabled, readyState: t.readyState })),
              audioTracks: finalStream.getAudioTracks().map(t => ({ label: t.label, enabled: t.enabled, readyState: t.readyState }))
            });
          }
        }
      };

      mediaRecorderRef.current.onstop = () => {
        console.log('=== MediaRecorder stop event ===');
        console.log('üìÄ Available data chunks count:', chunksRef.current.length);
        console.log('üìÑ Data chunk size list:', chunksRef.current.map(c => c.size));
        
        if (chunksRef.current.length === 0) {
          console.error('‚ùå Ëá¥ÂëΩÈîôËØØ: Ê≤°ÊúâÊî∂ÈõÜÂà∞‰ªª‰ΩïÊï∞ÊçÆÔºÅ');
          
          let errorMessage = 'Recording failed: No video data collected';
          
          if (browser.isFirefox) {
            console.error('ü§ä Firefox Ê≤°ÊúâÊï∞ÊçÆÂùóÔºåÂèØËÉΩÂéüÂõ†:');
            console.error('- Â™í‰ΩìÊµÅÊ≤°ÊúâÊ≠£Á°ÆÂêØÂä®ÊàñÂ∑≤Ë¢´ÂÅúÊ≠¢');
            console.error('- MediaRecorder ‰∏çÊîØÊåÅÂΩìÂâçÂ™í‰ΩìÊ†ºÂºè');
            console.error('- Firefox ÁâπÂÆöÁöÑÊùÉÈôêÊàñÂÆâÂÖ®Á≠ñÁï•ÈôêÂà∂');
            console.error('- ÁΩëÁªúÊàñÊÄßËÉΩÈóÆÈ¢òÂØºËá¥Êï∞ÊçÆ‰∏¢Â§±');
            
            errorMessage = 'Firefox recording failed: Possible permission restriction or unsupported format, please check browser settings';
            
            // Ê£ÄÊü• MediaRecorder Áä∂ÊÄÅ
            console.log('MediaRecorder status:', {
              state: mediaRecorderRef.current?.state,
              mimeType: mediaRecorderRef.current?.mimeType,
              videoBitsPerSecond: mediaRecorderRef.current?.videoBitsPerSecond,
              audioBitsPerSecond: mediaRecorderRef.current?.audioBitsPerSecond
            });
          }
          
          // ËÆæÁΩÆÈîôËØØÁä∂ÊÄÅ
          setRecordingError(errorMessage);
          setRecordingState(prev => ({ ...prev, recordedBlob: null }));
          return;
        }
        
        // ‰ΩøÁî®Ê≠£Á°ÆÁöÑ MIME Á±ªÂûãÂàõÂª∫ blob
        const blobType = options.mimeType || 'video/webm';
        const blob = new Blob(chunksRef.current, { type: blobType });
        
        console.log('‚úÖ Successfully created recording Blob:', { 
          size: blob.size, 
          type: blob.type,
          sizeInKB: Math.round(blob.size / 1024),
          sizeInMB: Math.round(blob.size / 1024 / 1024 * 100) / 100,
          chunksUsed: chunksRef.current.length,
          browser: browser.name
        });
        
        if (blob.size === 0) {
          console.warn('‚ö†Ô∏è ÂàõÂª∫ÁöÑ blob Â§ßÂ∞è‰∏∫ 0ÔºÅËøôÂèØËÉΩ‰ºöÂØºËá¥È¢ÑËßàÈóÆÈ¢ò„ÄÇ');
        }
        
        // È™åËØÅ blob ÁöÑÊúâÊïàÊÄß
        if (!blob || blob.size === 0) {
          const errorMsg = blob ? 'Recording failed: Generated video file is empty' : 'Recording failed: No video data generated';
          console.error('ÂΩïÂà∂ÂÅúÊ≠¢‰ΩÜÊ≤°ÊúâÁîüÊàêÊúâÊïàÁöÑBlobÊï∞ÊçÆ, size:', blob?.size);
          setRecordingError(errorMsg);
          setRecordingState(prev => ({ ...prev, recordedBlob: null }));
          return;
        }
        
        if (!(blob instanceof Blob)) {
          console.error('ÂΩïÂà∂Êï∞ÊçÆ‰∏çÊòØÊúâÊïàÁöÑBlobÂØπË±°:', typeof blob);
          setRecordingError('Recording failed: Data type error, please try recording again');
          setRecordingState(prev => ({ ...prev, recordedBlob: null }));
          return;
        }
        
        // Ê£ÄÊü•blobÁöÑÂü∫Êú¨ÊúâÊïàÊÄß
        if (blob.size < 1000) { // Â∞è‰∫é1KBÂèØËÉΩÊúâÈóÆÈ¢ò
          console.warn('Ë≠¶ÂëäÔºöÂΩïÂà∂Êñá‰ª∂ËøáÂ∞èÔºåÂèØËÉΩÂ≠òÂú®ÈóÆÈ¢ò, size:', blob.size);
          setRecordingError('Recording may have issues: File too small, recommend re-recording');
          // ‰∏çÁõ¥Êé•ËøîÂõûÔºåËÆ©Áî®Êà∑ÁúãÂà∞ËßÜÈ¢ëÂπ∂ÂÜ≥ÂÆöÊòØÂê¶ÈáçÊñ∞ÂΩïÂà∂
        }
        
        console.log('Recording stopped, generated Blob information:', {
          size: blob.size,
          type: blob.type,
          sizeKB: Math.round(blob.size / 1024),
          constructor: blob.constructor.name
        });
        
        // Ê∏ÖÈô§‰πãÂâçÁöÑÂΩïÂà∂ÈîôËØØÔºàÂ¶ÇÊûúÊúâÁöÑËØùÔºâ
        if (recordingError) {
          setRecordingError(null);
        }
        
        // Á´ãÂç≥ËÆæÁΩÆ blobÔºå‰∏çÁ≠âÂæÖÊ∏ÖÁêÜÂÆåÊàê
        setRecordingState(prev => {
          console.log('Setting recordedBlob:', blob);
          const newState = { ...prev, recordedBlob: blob };
          
          // ‰∏çÂÜçÈúÄË¶ÅlocalStorageÂ§á‰ªΩÔºåÂõ†‰∏∫ÁôªÂΩï‰∏ç‰ºöÂà∑Êñ∞È°µÈù¢
          console.log('Recording completed, state managed in memory');
          
          return newState;
        });
        
        console.log('Recording stopped, starting media stream cleanup...');
        
        // ÂÖ®Èù¢Ê∏ÖÁêÜÊâÄÊúâÂ™í‰ΩìÊµÅ
        if (screenStreamRef.current) {
          console.log('Stopping screen/desktop sharing stream...');
          screenStreamRef.current.getTracks().forEach(track => {
            console.log(`Stopping screen track: ${track.kind} - ${track.label}`);
            track.stop();
          });
          screenStreamRef.current = null;
        }
        
        if (cameraStreamRef.current) {
          console.log('Stopping camera stream during recording...');
          cameraStreamRef.current.getTracks().forEach(track => {
            console.log(`Stopping recording camera track: ${track.kind} - ${track.label}`);
            track.stop();
          });
          cameraStreamRef.current = null;
        }
        
        // ÂØπ‰∫éFirefoxÔºåÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ‰ª•Á°Æ‰øùÂÖ®Èù¢Ê∏ÖÁêÜ
        const isFirefox = navigator.userAgent.includes('Firefox');
        if (isFirefox) {
          console.log('Firefox detected, performing enhanced cleanup...');
          
          // Â∞ùËØïÂÅúÊ≠¢ÊâÄÊúâÂèØËÉΩÁöÑÂ™í‰ΩìËΩ®ÈÅì
          const allTracks = [...(navigator.mediaDevices as any).getAllActiveTracks?.() || []];
          allTracks.forEach((track: MediaStreamTrack) => {
            if (track.readyState === 'live') {
              console.log(`Stopping active track: ${track.kind} - ${track.label}`);
              track.stop();
            }
          });
          
          // FirefoxÁâπÊÆäÂ§ÑÁêÜÔºöÂ∞ùËØïÂÅúÊ≠¢ÊâÄÊúâÊ¥ªÂä®ÁöÑÂ±èÂπïÂÖ±‰∫´
          try {
            // Ê£ÄÊü•ÊòØÂê¶ÊúâÊ¥ªÂä®ÁöÑÂ±èÂπïÂÖ±‰∫´
            if (navigator.mediaDevices && (navigator.mediaDevices as any).getDisplayMedia) {
              console.log('Firefox checking and stopping all active display streams...');
              
              // Âú®Firefox‰∏≠ÔºåÂ∞ùËØïÈÄöËøáÊ£ÄÊü•document.hiddenÂíåËßÜÈ¢ëËΩ®ÈÅìÁä∂ÊÄÅÊù•Á°Æ‰øùÊ∏ÖÁêÜ
              const videoTracks = document.querySelectorAll('video');
              videoTracks.forEach((video, index) => {
                if (video !== cameraPreviewRef.current && video.srcObject) {
                  console.log(`Stopping video element ${index} stream`);
                  const stream = video.srcObject as MediaStream;
                  if (stream) {
                    stream.getTracks().forEach(track => {
                      console.log(`Stopping video element track: ${track.kind} - ${track.label}`);
                      track.stop();
                    });
                    video.srcObject = null;
                  }
                }
              });
            }
          } catch (cleanupError) {
            console.warn('FirefoxÊ∏ÖÁêÜËøáÁ®ã‰∏≠Âá∫Áé∞ÈùûËá¥ÂëΩÈîôËØØ:', cleanupError);
          }
          
          // Âª∂ËøüÊõ¥ÈïøÊó∂Èó¥ÂÜçÈáçÂêØÊëÑÂÉèÂ§¥È¢ÑËßàÔºå‰ΩÜ‰∏çÂΩ±ÂìçÈ¢ÑËßàÈ°µÊòæÁ§∫
          setTimeout(() => {
            if (includeCamera) {
              console.log('Firefox delayed restart of camera preview...');
              startCameraPreview();
            }
          }, 2000); // FirefoxÈúÄË¶ÅÊõ¥ÈïøÁöÑÂª∂Ëøü
        } else {
          // ÂÖ∂‰ªñÊµèËßàÂô®ÁöÑÊ≠£Â∏∏Â§ÑÁêÜ
          console.log('Recording completed, camera picture-in-picture preview continues to stay enabled');
        }
        
        // Á°Æ‰øùÈ¢ÑËßàÈ°µËÉΩÂ§üÁ´ãÂç≥ÊòæÁ§∫
        console.log('Recording stopped, preview should now be available');
        
        // ÂØπ‰∫éFirefoxÔºåÊ∑ªÂä†È¢ùÂ§ñÁöÑÁä∂ÊÄÅÊ£ÄÊü•ÂíåÂº∫Âà∂Êõ¥Êñ∞
        if (isFirefox) {
          // Â§öÊ¨°Â∞ùËØïËÆæÁΩÆblob‰ª•Á°Æ‰øùFirefoxÊ≠£Á°ÆÊõ¥Êñ∞Áä∂ÊÄÅ
          const attempts = [100, 300, 600, 1000];
          attempts.forEach((delay, index) => {
            setTimeout(() => {
              console.log(`Firefox: Attempt ${index + 1} to check and set blob`);
              
              setRecordingState(prev => {
                const hasValidBlob = prev.recordedBlob && prev.recordedBlob.size > 0;
                console.log('Firefox status check:', {
                  isRecording: prev.isRecording,
                  hasBlob: !!prev.recordedBlob,
                  blobSize: prev.recordedBlob?.size || 0,
                  shouldShowPreview: hasValidBlob && !recordingState.isRecording
                });
                
                if (!hasValidBlob) {
                  console.log('Firefox: Re-setting blob');
                  return { ...prev, recordedBlob: blob };
                }
                return prev;
              });
            }, delay);
          });
        }
      };

      // Firefox ‰ºòÂåñ: ‰ΩøÁî®Êõ¥Áü≠ÁöÑÊó∂Èó¥ÁâáÊÆµÊù•ÊèêÈ´òÊï∞ÊçÆÊî∂ÈõÜÈ¢ëÁéá
      const timeSlice = browser.isFirefox ? 100 : 1000; // Firefox ‰ΩøÁî® 100msÔºåÂÖ∂‰ªñ 1000ms
      console.log(`üé• Starting recording - time slice: ${timeSlice}ms, browser: ${browser.name}`);
      
      try {
        mediaRecorderRef.current.start(timeSlice);
        console.log('‚úÖ MediaRecorder started successfully');
      } catch (startError) {
        console.error('‚ùå MediaRecorder ÂêØÂä®Â§±Ë¥•:', startError);
        throw startError;
      }
      startTimer();
      
      // ËÆ∞ÂΩïÂºÄÂßãÊó∂Èó¥
      recordingStartTimeRef.current = Date.now();
      
      setRecordingState(prev => ({ 
        ...prev, 
        isRecording: true, 
        duration: 0,
        recordedBlob: null
      }));
      
      // Start speech recognition if subtitles enabled
      if (subtitleState.isEnabled && includeAudio) {
        setTimeout(() => {
          startSpeechRecognition();
        }, 1000); // Á®çÂæÆÂª∂Ëøü‰ª•Á°Æ‰øùÈü≥È¢ëÊµÅÂ∑≤ÁªèÂª∫Á´ã
      }

    } catch (error) {
      console.error('Failed to start recording:', error);

    }
  };

  const pauseRecording = () => {
    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
      mediaRecorderRef.current.pause();
      stopTimer();
      setRecordingState(prev => ({ ...prev, isPaused: true }));
      // Stop speech recognition when paused
      stopSpeechRecognition();
    }
  };

  const resumeRecording = () => {
    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'paused') {
      mediaRecorderRef.current.resume();
      startTimer();
      setRecordingState(prev => ({ ...prev, isPaused: false }));
      // Restart speech recognition when resumed
      if (subtitleState.isEnabled && includeAudio) {
        setTimeout(() => {
          startSpeechRecognition();
        }, 500);
      }
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current) {
      console.log('Stopping recording...');
      console.log('Current recording state:', recordingState);
      console.log('Chunks before stop:', chunksRef.current.length);
      
      mediaRecorderRef.current.stop();
      stopTimer();
      
      // Á´ãÂç≥Êõ¥Êñ∞ÂΩïÂà∂Áä∂ÊÄÅ
      setRecordingState(prev => {
        console.log('Updating recording state to stopped');
        return { 
          ...prev, 
          isRecording: false, 
          isPaused: false 
        };
      });
      
      // Stop speech recognition
      stopSpeechRecognition();
      
      // ÈáçÁΩÆÂºÄÂßãÊó∂Èó¥
      recordingStartTimeRef.current = 0;
      
      // Reset time warning states
      setShowTimeWarning(false);
      setIsNearTimeLimit(false);
      
      // ÂØπ‰∫éÈùûFirefoxÊµèËßàÂô®ÔºåÂú®stopRecording‰∏≠‰πüÈáçÂêØÈ¢ÑËßà
      const isFirefox = navigator.userAgent.includes('Firefox');
      if (!isFirefox) {
        setTimeout(() => {
          if (includeCamera) {
            console.log('Non-Firefox browser restarting camera preview...');
            startCameraPreview();
          }
        }, 500); // Á®çÂæÆÂª∂Ëøü‰ª•Á°Æ‰øùÂΩïÂà∂ÂÆåÂÖ®ÂÅúÊ≠¢
      } else {
        console.log('Firefox detected, delayed handling of camera preview in onstop');
      }
    }
  };

  const downloadRecording = () => {
    if (recordingState.recordedBlob) {
      const url = URL.createObjectURL(recordingState.recordedBlob);
      const a = document.createElement('a');
      a.href = url;
      
      // Use user input title or default title for filename
      const finalTitle = videoTitle.trim() || getDefaultTitle();
      // Clean filename by removing invalid characters
      const cleanTitle = finalTitle.replace(/[<>:"/\|?*]/g, '-');
      a.download = `${cleanTitle}.webm`;
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  };

  const uploadToAppwrite = async () => {
    if (!recordingState.recordedBlob) {

      return;
    }
    
    if (!user) {

      return;
    }

    console.log('User authenticated:', {
      userId: user.id,
      userEmail: user.email,
      userName: user.name
    });

    setIsUploading(true);
    try {
      // Generate unique filename
      const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
      const filename = `recording-${timestamp}.webm`;
      
      const file = new File(
        [recordingState.recordedBlob], 
        filename, 
        { type: 'video/webm' }
      );

      // Prepare form data
      const formData = new FormData();
      formData.append('file', file);
      formData.append('title', videoTitle.trim() || getDefaultTitle());
      formData.append('quality', quality);
      formData.append('duration', recordingState.duration.toString());
      formData.append('isPublic', isVideoPublic.toString());
      formData.append('isPublish', isVideoPublished.toString());
      formData.append('thumbnailUrl', '');

      console.log('Uploading file using server action...');
      
      // Upload video using server action
      const result = await uploadVideoFileAction(formData);
      
      if (result.error) {
        throw new Error(result.error);
      }

      console.log('File uploaded successfully:', result.data);

      // Handle subtitle file if subtitles were generated  
      // TODO: Add subtitle file upload to server action if needed
      if (subtitleState.segments.length > 0) {
        console.log('Note: Subtitle file upload not yet implemented in server actions');
      }
      
      console.log('‚úÖ Recording uploaded successfully.');
      

      
      // Save uploaded video data for display
      const uploadedVideoData = { $id: result.data?.videoId, title: videoTitle.trim() || getDefaultTitle() };
      setUploadedVideo(uploadedVideoData);
      
      console.log('Upload successful, recording state managed in memory');
      
      // Âú®ÂêéÂè∞Ëá™Âä®ÁîüÊàêÁº©Áï•Âõæ
      if (recordingState.recordedBlob && uploadedVideoData.$id) {
        generateThumbnailInBackground(uploadedVideoData.$id, recordingState.recordedBlob);
      }
      
      // Keep recording blob for preview, don't clear it yet
      // The blob will be cleared when starting new recording

    } catch (error: any) {
      console.error('Upload failed. Error details:', error);

    } finally {
      setIsUploading(false);
    }
  };

  return (
    <TooltipProvider>
      <div className="space-y-4">
      {/* Recording Controls */}
      {!recordingState.isRecording && !recordingState.recordedBlob && (
        <Card>
          <CardContent className="px-6 py-1">
            <div className="space-y-4">
          {/* Á¨¨‰∏ÄË°åÔºöÂΩïÂà∂Ë¥®ÈáèÂíåÂΩïÂà∂Ê∫ê */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="select-container">
              <Label className="text-sm font-medium mb-3 block">{RECORDING.recordingQuality}</Label>
              <Select value={quality} onValueChange={(value) => setQuality(value as RecordingQuality)}>
                <SelectTrigger className="w-full">
                  <SelectValue placeholder={RECORDING.selectRecordingQuality} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="720p">720p (1280x720)</SelectItem>
                  <SelectItem value="1080p">1080p (1920x1080)</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="select-container">
              <Label className="text-sm font-medium mb-3 block">{RECORDING.recordingSource}</Label>
              <Select 
                value={source === 'camera-only' ? 'camera-only' : screenSource} 
                onValueChange={(value) => {
                  if (value === 'camera-only') {
                    setSource('camera-only' as RecordingSource);
                    setIncludeCamera(true); // Ëá™Âä®ÂºÄÂêØÊëÑÂÉèÂ§¥
                  } else {
                    // Â¶ÇÊûú‰πãÂâçÊòØcamera-onlyÔºåÁé∞Âú®ÂàáÊç¢Âà∞Â±èÂπïÂΩïÂà∂ÔºåÈúÄË¶ÅËÆæÁΩÆ‰∏∫screenÊ®°Âºè
                    if (source === 'camera-only') {
                      setSource('screen' as RecordingSource);
                    }
                    setScreenSource(value as ScreenSourceType);
                  }
                }}
              >
                <SelectTrigger className="w-full">
                  <SelectValue placeholder={RECORDING.selectRecordingSource} />
                </SelectTrigger>
                <SelectContent>
                  {(() => {
                    const browser = detectBrowserFromLib();
                    
                    // Chrome/Edge: ÊòæÁ§∫ÂÆåÊï¥ÈÄâÈ°πÔºàÂ±èÂπï„ÄÅÁ™óÂè£„ÄÅÊ†áÁ≠æÈ°µ„ÄÅÊëÑÂÉèÂ§¥Ôºâ
                    if (browser.supportsDisplaySurface) {
                      return (
                        <>
                          <SelectItem value="monitor">
                            <div className="w-full">
                              <div className="flex items-center">
                                <Monitor className="h-4 w-4 mr-2 flex-shrink-0" />
                                <span className="font-medium">{RECORDING.entireScreen}</span>
                              </div>
                              <div className="text-xs text-muted-foreground mt-1">
                                {RECORDING.entireScreenDesc}
                              </div>
                            </div>
                          </SelectItem>
                          <SelectItem value="window">
                            <div className="w-full">
                              <div className="flex items-center">
                                <Square className="h-4 w-4 mr-2 flex-shrink-0" />
                                <span className="font-medium">{RECORDING.applicationWindow}</span>
                              </div>
                              <div className="text-xs text-muted-foreground mt-1">
                                {RECORDING.applicationWindowDesc}
                              </div>
                            </div>
                          </SelectItem>
                          <SelectItem value="browser">
                            <div className="w-full">
                              <div className="flex items-center">
                                <Globe className="h-4 w-4 mr-2 flex-shrink-0" />
                                <span className="font-medium">{RECORDING.browserTab}</span>
                              </div>
                              <div className="text-xs text-muted-foreground mt-1">
                                {RECORDING.browserTabDesc}
                              </div>
                            </div>
                          </SelectItem>
                          <SelectItem value="camera-only">
                            <div className="w-full">
                              <div className="flex items-center">
                                <Camera className="h-4 w-4 mr-2 flex-shrink-0" />
                                <span className="font-medium">{RECORDING.cameraOnly}</span>
                              </div>
                              <div className="text-xs text-muted-foreground mt-1">
                                {RECORDING.cameraOnlyDesc}
                              </div>
                            </div>
                          </SelectItem>
                        </>
                      );
                    } else {
                      // Safari/Firefox: Âè™ÊòæÁ§∫Á≥ªÁªüËÆæÁΩÆÂíåÊëÑÂÉèÂ§¥Ôºå‰ΩøÁî®Â§öËØ≠Ë®Ä
                      return (
                        <>
                          <SelectItem value="monitor">
                            <div className="w-full">
                              <div className="flex items-center">
                                <Monitor className="h-4 w-4 mr-2 flex-shrink-0" />
                                <span className="font-medium">{RECORDING.systemSettings}</span>
                              </div>
                              <div className="text-xs text-muted-foreground mt-1">
                                {RECORDING.systemSettingsDesc}
                              </div>
                            </div>
                          </SelectItem>
                          <SelectItem value="camera-only">
                            <div className="w-full">
                              <div className="flex items-center">
                                <Camera className="h-4 w-4 mr-2 flex-shrink-0" />
                                <span className="font-medium">{RECORDING.cameraOnly}</span>
                              </div>
                              <div className="text-xs text-muted-foreground mt-1">
                                {RECORDING.cameraOnlyDesc}
                              </div>
                            </div>
                          </SelectItem>
                        </>
                      );
                    }
                  })()
                  }
                </SelectContent>
              </Select>
            </div>
          </div>
          
          {/* Á¨¨‰∫åË°åÔºöÈü≥È¢ëÂíåÊëÑÂÉèÂ§¥ÊéßÂà∂ */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                {includeAudio ? <Mic className="h-4 w-4" /> : <MicOff className="h-4 w-4" />}
                <div className="flex flex-col">
                  <Label>{RECORDING.openMicrophone}</Label>
                  <p className="text-xs text-muted-foreground">
                    {RECORDING.microphoneDescription}
                  </p>
                </div>
                {/* Microphone status indicator */}
                {includeAudio && (
                  <div 
                    className="w-2 h-2 bg-green-500 rounded-full animate-pulse"
                    title={RECORDING.microphoneEnabled}
                  ></div>
                )}
              </div>
              <Switch
                checked={includeAudio}
                onCheckedChange={async (checked) => {
                  if (checked) {
                    // Check if we're in an iframe first
                    if (isInIframe()) {
                      const shouldOpenNewWindow = confirm(
                        DEVICES.iframeMediaBlocked + '\n\nWould you like to open this page in a new window?'
                      );
                      if (shouldOpenNewWindow) {
                        openInNewWindow();
                      }
                      setIncludeAudio(false);
                      return;
                    }
                    
                    // Check if media access is blocked (no secure context)
                    if (isMediaAccessBlocked()) {
                      alert('Microphone access requires a secure connection (HTTPS). Please use HTTPS or localhost.');
                      setIncludeAudio(false);
                      return;
                    }
                    
                    // Request microphone permission when user enables it
                    try {
                      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                      // Stop the stream immediately after getting permission
                      stream.getTracks().forEach(track => track.stop());
                      setIncludeAudio(true);
                      console.log('Microphone permission granted successfully');
                    } catch (error) {
                      console.error('Microphone permission request failed:', error);
                      setIncludeAudio(false);
                      
                      // Show user-friendly error message
                      let errorMessage: string = PERMISSIONS.microphoneDenied;
                      if (error instanceof DOMException) {
                        switch (error.name) {
                          case 'NotAllowedError':
                            errorMessage = 'Microphone access denied. Please allow microphone access in your browser settings and try again.';
                            break;
                          case 'NotFoundError':
                            errorMessage = PERMISSIONS.microphoneNotFound;
                            break;
                          case 'NotReadableError':
                            errorMessage = 'Microphone is being used by another application. Please close other applications using the microphone and try again.';
                            break;
                          default:
                            errorMessage = `Microphone error: ${error.message}`;
                        }
                      }
                      
                      // Show alert with error message
                      if (typeof window !== 'undefined') {
                        alert(errorMessage);
                      }
                    }
                  } else {
                    setIncludeAudio(false);
                  }
                }}
              />
      
      {/* Firefox specific CSS - Only show picture-in-picture button */}
      <style jsx global>{`
        /* Firefox media controls complete hiding strategy */
        .firefox-pip-video {
          position: relative !important;
          background: #000 !important;
        }
        
        /* Hide Firefox native controls through multiple methods */
        .firefox-pip-video[controls] {
          /* Try to hide the entire control bar */
        }
        
        .firefox-pip-video::-moz-media-controls {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
          display: none !important;
          height: 0 !important;
          width: 0 !important;
          overflow: hidden !important;
          -moz-appearance: none !important;
        }
        
        /* Hide Firefox control panel */
        .firefox-pip-video::-moz-media-controls-panel {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
          display: none !important;
        }
        
        /* Hide play/pause buttons */
        .firefox-pip-video::-moz-media-controls-play-button,
        .firefox-pip-video::-moz-media-controls-overlay-play-button {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
          display: none !important;
        }
        
        /* Hide time controls */
        .firefox-pip-video::-moz-media-controls-scrubber,
        .firefox-pip-video::-moz-media-controls-time-display,
        .firefox-pip-video::-moz-media-controls-current-time,
        .firefox-pip-video::-moz-media-controls-duration {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
          display: none !important;
        }
        
        /* Hide volume controls */
        .firefox-pip-video::-moz-media-controls-volume-control,
        .firefox-pip-video::-moz-media-controls-mute-button,
        .firefox-pip-video::-moz-media-controls-volume-slider {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
          display: none !important;
        }
        
        /* Hide fullscreen button */
        .firefox-pip-video::-moz-media-controls-fullscreen-button {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
          display: none !important;
        }
        
        /* Firefox latest version control structure */
        .firefox-pip-video video::-moz-media-controls,
        .firefox-pip-video::-moz-media-controls-button-panel,
        .firefox-pip-video::-moz-media-controls-statusbar {
          visibility: hidden !important;
          opacity: 0 !important;
          display: none !important;
          height: 0 !important;
        }
        
        /* Firefox 130+ new control selectors */
        .firefox-pip-video div[role="group"],
        .firefox-pip-video div[class*="control"],
        .firefox-pip-video button:not([title*="picture"]):not([title*="Picture"]) {
          visibility: hidden !important;
          opacity: 0 !important;
          display: none !important;
        }
        
        /* Show and optimize picture-in-picture button - Firefox */
        .firefox-pip-video::-moz-media-controls-picture-in-picture-button,
        .firefox-pip-video button[title*="picture"],
        .firefox-pip-video button[title*="Picture"] {
          visibility: visible !important;
          opacity: 1 !important;
          pointer-events: all !important;
          display: block !important;
          position: relative !important;
          background: rgba(0, 0, 0, 0.8) !important;
          border-radius: 6px !important;
          padding: 4px !important;
          margin: 4px !important;
          border: 1px solid rgba(255, 255, 255, 0.2) !important;
          transition: all 0.2s ease !important;
          z-index: 9999 !important;
        }
        
        .firefox-pip-video::-moz-media-controls-picture-in-picture-button:hover {
          background: rgba(0, 0, 0, 0.9) !important;
          border-color: rgba(255, 255, 255, 0.4) !important;
          transform: scale(1.05) !important;
        }
        
        /* Hide Firefox overlay and other elements */
        .firefox-pip-video::-moz-media-controls-overlay {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
          display: none !important;
        }
        
        /* Hide other possible controls */
        .firefox-pip-video::-moz-media-controls > *:not(button[title*="Picture-in-Picture"]):not([aria-label*="Picture-in-Picture"]) {
          visibility: hidden !important;
          opacity: 0 !important;
          display: none !important;
        }
        
        /* Compatible with WebKit browsers (if Firefox uses WebKit engine) */
        .firefox-pip-video::-webkit-media-controls {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
        }
        
        .firefox-pip-video::-webkit-media-controls-panel {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
        }
        
        /* WebKit Êí≠ÊîæÊåâÈíÆÈöêËóè */
        .firefox-pip-video::-webkit-media-controls-play-button,
        .firefox-pip-video::-webkit-media-controls-overlay-play-button {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
        }
        
        /* WebKit Êó∂Èó¥ËΩ¥ÈöêËóè */
        .firefox-pip-video::-webkit-media-controls-timeline,
        .firefox-pip-video::-webkit-media-controls-timeline-container,
        .firefox-pip-video::-webkit-media-controls-current-time-display,
        .firefox-pip-video::-webkit-media-controls-time-remaining-display {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
        }
        
        /* WebKit Èü≥ÈáèÊéß‰ª∂ÈöêËóè */
        .firefox-pip-video::-webkit-media-controls-volume-slider,
        .firefox-pip-video::-webkit-media-controls-mute-button {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
        }
        
        /* WebKit ÂÖ®Â±èÊåâÈíÆÈöêËóè */
        .firefox-pip-video::-webkit-media-controls-fullscreen-button {
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
        }
        
        /* WebKit Áîª‰∏≠ÁîªÊåâÈíÆÊòæÁ§∫ */
        .firefox-pip-video::-webkit-media-controls-picture-in-picture-button {
          visibility: visible !important;
          opacity: 1 !important;
          pointer-events: all !important;
          background: rgba(0, 0, 0, 0.8) !important;
          border-radius: 6px !important;
          padding: 4px !important;
          margin: 4px !important;
        }
      `}</style>

            </div>
            
            {/* Â≠óÂπïËÆæÁΩÆ */}
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                <div className="w-5 h-5 flex items-center justify-center">
                  {subtitleState.isEnabled ? (
                    <span className="text-xs font-bold">CC</span>
                  ) : (
                    <span className="text-xs font-bold text-muted-foreground">CC</span>
                  )}
                </div>
                <div className="flex flex-col">
                  <Label>{SUBTITLES.enableSubtitles}</Label>
                  {SUBTITLES.subtitleDescription && (
                    <p className="text-xs text-muted-foreground">
                      {SUBTITLES.subtitleDescription}
                    </p>
                  )}
                  {!includeAudio && (
                    <span className="text-xs text-muted-foreground">
                      {SUBTITLES.needMicrophoneForSubtitles}
                    </span>
                  )}
                </div>
                {/* Â≠óÂπïÁä∂ÊÄÅÊåáÁ§∫Âô® */}
                {subtitleState.isListening && (
                  <div 
                    className="w-2 h-2 bg-blue-500 rounded-full animate-pulse"
                    title={SUBTITLES.listeningForSpeech}
                  ></div>
                )}
              </div>
              <div className="flex items-center space-x-2">
                {subtitleState.isEnabled && includeAudio && (
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => setShowSubtitleSettings(!showSubtitleSettings)}
                  >
                    <Settings className="h-3 w-3" />
                  </Button>
                )}
                <Switch
                  checked={subtitleState.isEnabled}
                  onCheckedChange={(checked) => {
                    if (checked && !includeAudio) {

                      return;
                    }
                    setSubtitleState(prev => ({ ...prev, isEnabled: checked }));
                    if (!checked) {
                      stopSpeechRecognition();
                    }
                  }}
                  disabled={!includeAudio}
                />
              </div>
            </div>
            
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                {includeCamera ? <Camera className="h-4 w-4" /> : <CameraOff className="h-4 w-4" />}
                <div className="flex flex-col">
                  <Label>{RECORDING.enableCamera}</Label>
                  {/* Camera not supported notification */}
                  {(screenSource === 'window' || screenSource === 'browser') && source !== 'camera-only' && (
                    <span className="text-xs text-muted-foreground">
                      {screenSource === 'window' ? RECORDING.windowNotSupportCamera : RECORDING.browserTabNotSupportCamera}
                    </span>
                  )}
                </div>
                {/* Camera status indicator */}
                {includeCamera && cameraPreviewStream && (
                  <div 
                    className="w-2 h-2 bg-green-500 rounded-full animate-pulse"
                    title={RECORDING.cameraEnabled}
                  ></div>
                )}
              </div>
              <div className="flex items-center space-x-2">
                <Switch
                  checked={includeCamera}
                  onCheckedChange={async (checked) => {
                    // When only camera recording is selected, don't allow turning off camera
                    if (source === 'camera-only' && !checked) {
                      return; // Don't allow turning off
                    }
                    
                    if (checked) {
                      // Check if we're in an iframe first
                      if (isInIframe()) {
                        const shouldOpenNewWindow = confirm(
                          DEVICES.iframeMediaBlocked + '\n\nWould you like to open this page in a new window?'
                        );
                        if (shouldOpenNewWindow) {
                          openInNewWindow();
                        }
                        setIncludeCamera(false);
                        return;
                      }
                      
                      // Check if media access is blocked (no secure context)
                      if (isMediaAccessBlocked()) {
                        alert('Camera access requires a secure connection (HTTPS). Please use HTTPS or localhost.');
                        setIncludeCamera(false);
                        return;
                      }
                      
                      // Request camera permission when user enables it
                      try {
                        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                        // Stop test stream immediately, actual stream will be obtained in startCameraPreview
                        stream.getTracks().forEach(track => track.stop());
                        setIncludeCamera(true);
                        console.log('Camera permission granted successfully');
                      } catch (error) {
                        console.error('Camera permission request failed:', error);
                        setIncludeCamera(false);
                        
                        // Show user-friendly error message
                        let errorMessage: string = PERMISSIONS.cameraDenied;
                        if (error instanceof DOMException) {
                          switch (error.name) {
                            case 'NotAllowedError':
                              errorMessage = 'Camera access denied. Please allow camera access in your browser settings and try again.';
                              break;
                            case 'NotFoundError':
                              errorMessage = PERMISSIONS.cameraNotFound;
                              break;
                            case 'NotReadableError':
                              errorMessage = 'Camera is being used by another application. Please close other applications using the camera and try again.';
                              break;
                            default:
                              errorMessage = `Camera error: ${error.message}`;
                          }
                        }
                        
                        // Show alert with error message
                        if (typeof window !== 'undefined') {
                          alert(errorMessage);
                        }
                      }
                    } else {
                      setIncludeCamera(false);
                    }
                  }}
                  disabled={
                    source === 'camera-only' || // Disable switching when only recording camera
                    (screenSource === 'window' || screenSource === 'browser') // Application windows and browser tabs don't support camera
                  }
                />
              </div>
            </div>
            
            {/* Â≠óÂπïËÆæÁΩÆÈù¢Êùø */}
            {showSubtitleSettings && subtitleState.isEnabled && includeAudio && (
              <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 space-y-3">
                <div className="flex items-center justify-between">
                  <Label className="text-sm font-medium">
                    {SUBTITLES.subtitleLanguage}
                  </Label>
                  <Select
                    value={subtitleState.language}
                    onValueChange={(value) => {
                      setSubtitleState(prev => ({ ...prev, language: value }));
                      // ÈáçÊñ∞ÂàùÂßãÂåñËØ≠Èü≥ËØÜÂà´‰ª•Â∫îÁî®Êñ∞ËØ≠Ë®Ä
                      if (subtitleState.isListening) {
                        stopSpeechRecognition();
                        setTimeout(() => {
                          if (recordingState.isRecording && includeAudio) {
                            startSpeechRecognition();
                          }
                        }, 500);
                      }
                    }}
                  >
                    <SelectTrigger className="w-32">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="zh-CN">Chinese (Simplified)</SelectItem>
                      <SelectItem value="en-US">English (US)</SelectItem>
                      <SelectItem value="ja-JP">Japanese</SelectItem>
                      <SelectItem value="ko-KR">Korean</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                
                <div className="text-xs text-muted-foreground">
                  {SUBTITLES.subtitleInfo}
                </div>
              </div>
            )}
          </div>
          
          {/* Start Recording Button */}
          <div className="pt-4">
            <Button onClick={startRecording} className="w-full" size="lg">
              <Circle className="h-5 w-5 mr-2 fill-current" />
              {RECORDING.start}
            </Button>
          </div>
            </div>
          </CardContent>
        </Card>
      )}


      

      
      {/* ÊëÑÂÉèÂ§¥È¢ÑËßàËßÜÈ¢ëÂÖÉÁ¥† - Ê†πÊçÆÁîª‰∏≠ÁîªÊîØÊåÅÂä®ÊÄÅÊòæÁ§∫/ÈöêËóè */}
      <video
        ref={cameraPreviewRef}
        className={`${detectPiPSupport().canAutoStart ? 'hidden' : cameraPreviewStream ? 'block' : 'hidden'} w-64 h-48 bg-black rounded-lg border border-gray-300 dark:border-gray-600 ${detectPiPSupport().browser === 'Safari' || detectPiPSupport().browser === 'Firefox' ? 'cursor-pointer hover:border-primary/50 transition-colors' : ''} ${detectPiPSupport().browser === 'Firefox' ? 'firefox-pip-video' : ''} relative`}
        autoPlay
        muted
        playsInline
        controls={detectPiPSupport().browser === 'Firefox'} // Âè™ÊúâFirefoxÊòæÁ§∫ÂéüÁîüÊéß‰ª∂‰ª•‰æø‰ΩøÁî®Áîª‰∏≠ÁîªÊåâÈíÆ
        controlsList={detectPiPSupport().browser === 'Firefox' ? 'nodownload nofullscreen noremoteplayback noplaybackrate' : undefined} // FirefoxÂ∞ΩÂèØËÉΩÈöêËóèÂÖ∂‰ªñÊéß‰ª∂
        onClick={async (e) => {
          // Áõ¥Êé•ÁÇπÂáªËßÜÈ¢ëÂÖÉÁ¥†ÂêØÂä®Áîª‰∏≠ÁîªÔºàÈÄÇÁî®‰∫éSafariÁ≠âÈúÄË¶ÅÁî®Êà∑ÊâãÂäøÁöÑÊµèËßàÂô®Ôºâ
          const pipSupport = detectPiPSupport();
          
          if (pipSupport.browser === 'Firefox') {
            // Firefox‰πüÊîØÊåÅÁÇπÂáªËßÜÈ¢ëÂêØÂä®Áîª‰∏≠ÁîªÔºåÂêåÊó∂‰øùÁïôÊéß‰ª∂‰∏≠ÁöÑÁîª‰∏≠ÁîªÊåâÈíÆ
            console.log('Firefox click video to try starting picture-in-picture');
            // ÁªßÁª≠ÊâßË°å‰∏ãÈù¢ÁöÑÈÄªËæëÔºå‰∏çreturn
          }
          
          e.preventDefault();
          if (cameraPreviewStream && !document.pictureInPictureElement && !isPiPRequesting) {
            console.log(`${pipSupport.browser} click video to try starting picture-in-picture`);
            
            if (pipSupport.supported && typeof cameraPreviewRef.current?.requestPictureInPicture === 'function') {
              try {
                setIsPiPRequestingWithTimeout(true);
                await cameraPreviewRef.current.requestPictureInPicture();
                console.log(`${pipSupport.browser} click video picture-in-picture started successfully`);

              } catch (error: any) {
                console.error(`${pipSupport.browser}ÁÇπÂáªËßÜÈ¢ëÂêØÂä®Â§±Ë¥•:`, error);
                if (pipSupport.browser === 'Safari') {

                } else if (pipSupport.browser === 'Firefox') {

                } else {

                }
              } finally {
                setIsPiPRequestingWithTimeout(false);
              }
            } else if (!pipSupport.supported) {
              // Browser does not support Picture in Picture
            }
          }
        }}
        onLoadedData={() => console.log('Video data loading completed')}
        onCanPlay={() => console.log('ËßÜÈ¢ëÂèØ‰ª•Êí≠Êîæ')}
        onError={(e) => console.error('ËßÜÈ¢ëÂÖÉÁ¥†ÈîôËØØ:', e)}
        disablePictureInPicture={detectPiPSupport().browser !== 'Firefox' && detectPiPSupport().browser !== 'Chrome'} // Âè™‰∏∫FirefoxÂíåChromeÂêØÁî®Áîª‰∏≠Áîª
      />
      
      {/* Áîª‰∏≠ÁîªÂºïÂØºÊèêÁ§∫ - Ê†πÊçÆÊµèËßàÂô®ÊòæÁ§∫‰∏çÂêåÂÜÖÂÆπ */}
      {(() => {
        const pipSupport = detectPiPSupport();
        const shouldShow = cameraPreviewStream && !pipSupport.canAutoStart && (
          pipSupport.supported || pipSupport.browser === 'Firefox'
        );
        return shouldShow;
      })() && (
        <Card className="mt-4 border-primary/20 dark:border-primary/30 bg-primary/5 dark:bg-primary/10">
          <CardContent className="px-6 py-1">
            <div className="flex items-start space-x-3">
              <ExternalLink className="h-5 w-5 text-primary mt-0.5 flex-shrink-0" />
              <div className="flex-1">
                {detectPiPSupport().browser === 'Safari' ? (
                  <div>
                    <h4 className="font-medium text-foreground mb-2">
                      ÁÇπÂáª‰∏äÊñπËßÜÈ¢ëÂêØÁî®Áîª‰∏≠Áîª
                    </h4>
                    <p className="text-sm text-muted-foreground">
                      ÂêØÁî®Áîª‰∏≠ÁîªÂêéÂèØÂú®ÂÖ∂‰ªñÂ∫îÁî®‰∏≠ÂΩïÂà∂ÊëÑÂÉèÂ§¥
                    </p>
                  </div>
                ) : detectPiPSupport().browser === 'Firefox' ? (
                  <div>
                    <h4 className="font-medium text-foreground mb-2">
                      ÁÇπÂáª‰∏äÊñπËßÜÈ¢ë‰∏≠ÁöÑÊåâÈíÆÂêØÁî®Áîª‰∏≠Áîª
                    </h4>
                    <p className="text-sm text-muted-foreground">
                      ÂêØÁî®Áîª‰∏≠ÁîªÂêéÂèØÂú®ÂÖ∂‰ªñÂ∫îÁî®‰∏≠ÂΩïÂà∂ÊëÑÂÉèÂ§¥
                    </p>
                  </div>
                ) : (
                  <div>
                    <h4 className="font-medium text-foreground mb-2">
                      ÂêØÁî®Áîª‰∏≠ÁîªÈ¢ÑËßà
                    </h4>
                    <p className="text-sm text-muted-foreground mb-3">
                      ÁÇπÂáª‰∏äÊñπËßÜÈ¢ëÊàñ‰∏ãÊñπÊåâÈíÆÂêØÁî®Áîª‰∏≠ÁîªÊ®°Âºè„ÄÇ
                    </p>
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={startPictureInPictureManually}
                      disabled={isPiPRequesting || !!document.pictureInPictureElement}
                      className="bg-primary/10 dark:bg-primary/20 border-primary/30 dark:border-primary/40 text-primary hover:bg-primary/20 dark:hover:bg-primary/30"
                    >
                      {isPiPRequesting ? (
                        <span className="flex items-center">
                          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-current mr-2"></div>
                          ÂêØÂä®‰∏≠...
                        </span>
                      ) : document.pictureInPictureElement ? (
                        'Áîª‰∏≠ÁîªÂ∑≤ÂêØÂä®'
                      ) : (
                        <span className="flex items-center">
                          <ExternalLink className="h-4 w-4 mr-2" />
                          ÂêØÂä®Áîª‰∏≠Áîª
                        </span>
                      )}
                    </Button>
                  </div>
                )}
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Recording Status */}
      {recordingState.isRecording && (
        <Card className={`transition-colors ${
          isNearTimeLimit 
            ? 'border-orange-300 dark:border-orange-700' 
            : ''
        }`}>
          <CardContent className="px-6 py-1 space-y-3">
            {/* Main Status Row */}
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-3">
                <div className="flex items-center space-x-2">
                  <div className={`w-3 h-3 rounded-full animate-pulse ${
                    isNearTimeLimit ? 'bg-orange-500' : 'bg-primary'
                  }`}></div>
                  <span className="font-medium">
                    {recordingState.isPaused ? RECORDING.paused : RECORDING.recordingStatus}
                  </span>
                </div>
                <span className={`font-mono text-lg ${
                  isNearTimeLimit ? 'text-orange-600 dark:text-orange-400 font-bold' : ''
                }`}>
                  {formatDuration(recordingState.duration)}
                </span>
                {recordingConfig.enableTimeLimit && (
                  <span className="text-sm text-muted-foreground">
                    / {formatDuration(recordingConfig.maxDurationSeconds)}
                  </span>
                )}
              </div>
              <div className="flex space-x-2">
                {!recordingState.isPaused ? (
                  <Button size="sm" variant="outline" onClick={pauseRecording}>
                    <Pause className="h-4 w-4" />
                  </Button>
                ) : (
                  <Button size="sm" variant="outline" onClick={resumeRecording}>
                    <Play className="h-4 w-4" />
                  </Button>
                )}
                <Button size="sm" onClick={stopRecording}>
                  <StopCircle className="h-4 w-4 mr-1" />
                  {RECORDING.stop}
                </Button>
              </div>
            </div>
            
            {/* Progress Bar */}
            {recordingConfig.enableTimeLimit && (
              <div className="w-full">
                <div className="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                  <div 
                    className={`h-full transition-all duration-300 ${
                      isNearTimeLimit 
                        ? 'bg-orange-500 dark:bg-orange-400' 
                        : 'bg-primary'
                    }`}
                    style={{
                      width: `${Math.min((recordingState.duration / recordingConfig.maxDurationSeconds) * 100, 100)}%`
                    }}
                  ></div>
                </div>
                {isNearTimeLimit && (
                  <p className="text-xs text-orange-600 dark:text-orange-400 mt-1 text-center">
                    {RECORDING.recordingWillStopAt()}
                  </p>
                )}
              </div>
            )}
            
            {/* Â≠óÂπïÂÆûÊó∂ÊòæÁ§∫ */}
            {subtitleState.isEnabled && includeAudio && (
              <div className="bg-black/80 rounded-lg p-3 min-h-[60px]">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-xs text-blue-400 font-medium">
                    {SUBTITLES.liveSubtitles}
                  </span>
                  {subtitleState.isListening && (
                    <div className="flex items-center space-x-1">
                      <div className="w-1 h-1 bg-blue-400 rounded-full animate-pulse"></div>
                      <span className="text-xs text-blue-400">
                        {SUBTITLES.listening}
                      </span>
                    </div>
                  )}
                </div>
                
                <div className="text-white text-sm leading-relaxed">
                  {subtitleState.currentText && (
                    <p className="text-gray-300 italic">
                      {subtitleState.currentText}
                    </p>
                  )}
                  
                  {subtitleState.segments.slice(-3).map((segment, index) => (
                    <p key={segment.id} className={`mb-1 ${
                      index === subtitleState.segments.slice(-3).length - 1 
                        ? 'text-white font-medium' 
                        : 'text-gray-400'
                    }`}>
                      <span className="text-xs text-gray-500 mr-2">
                        {formatDuration(segment.startTime)}
                      </span>
                      {segment.text}
                    </p>
                  ))}
                  
                  {!subtitleState.isListening && subtitleState.segments.length === 0 && !subtitleState.currentText && (
                    <p className="text-gray-500 text-center text-xs">
                      {SUBTITLES.waitingForSpeech}
                    </p>
                  )}
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      )}





      {/* Recording Error Display */}
      {recordingError && (
        <Card className="border-destructive/50">
          <CardContent className="px-6 py-1">
            <div className="text-center">
              <div className="w-12 h-12 mx-auto mb-4 rounded-full bg-destructive/20 flex items-center justify-center">
                <span className="text-destructive text-xl">‚ö†Ô∏è</span>
              </div>
              <h3 className="font-medium text-destructive mb-2">Recording Error</h3>
              <p className="text-sm text-muted-foreground mb-4">
                {recordingError}
              </p>
              <div className="space-y-2">
                <div className="text-xs text-muted-foreground">
                  <p>Suggested Solutions:</p>
                  <ul className="text-left mt-2 space-y-1">
                    <li>‚Ä¢ Check browser permission settings</li>
                    <li>‚Ä¢ Ensure the correct recording source is selected</li>
                    <li>‚Ä¢ Restart the recording</li>
                  </ul>
                </div>
                <Button 
                  onClick={() => {
                    setRecordingError(null);
                    startNewRecording();
                  }}
                  className="mt-4"
                >
                  Retry Recording
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Recording Complete - Not Uploaded Yet */}
      {recordingState.recordedBlob && !uploadedVideo && !recordingError && (
        <Card>
          <CardContent className="px-6 py-1">
            <div className="space-y-4">
              <div className="text-center">
                <h3 className="font-medium">{RECORDING.recordingComplete}</h3>
                <p className="text-sm text-muted-foreground">
                  {RECORDING.duration}: {formatDuration(recordingState.duration)}
                </p>
              </div>
              
              {/* Video Preview */}
              <div className="space-y-3">
                <div className="mx-auto max-w-md">
                  <div className="aspect-video bg-muted rounded-lg overflow-hidden">
                    <RestoreableVideo 
                      blob={recordingState.recordedBlob}
                      className="w-full h-full object-cover"
                    />
                  </div>
                </div>

              </div>
              
              {/* Video Title Input */}
              <div>
                <Label htmlFor="videoTitle" className="text-sm font-medium mb-2 block">
                  {RECORDING.videoTitle}
                </Label>
                <Input
                  id="videoTitle"
                  value={videoTitle}
                  onChange={(e) => setVideoTitle(e.target.value)}
                  placeholder={getDefaultTitle()}
                  className="w-full"
                />
              </div>
              
              {/* Public/Private and Publish to Discovery Toggles */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="flex items-center justify-between">
                  <div>
                    <Label className="text-sm font-medium">
                      {RECORDING.publicVideo}
                    </Label>
                    <p className="text-xs text-muted-foreground">
                      {isVideoPublic ? RECORDING.publicVideoDesc : RECORDING.privateVideoDesc}
                    </p>
                  </div>
                  <Switch
                    checked={isVideoPublic}
                    onCheckedChange={setIsVideoPublic}
                  />
                </div>
                
                <div className="flex items-center justify-between">
                  <div>
                    <Label className="text-sm font-medium">
                      {VIDEOS.publishToDiscovery}
                    </Label>
                    <p className="text-xs text-muted-foreground">
                      {isVideoPublished ? PUBLISH.publishedDescription : PUBLISH.unpublishedDescription}
                    </p>
                  </div>
                  <Switch
                    checked={isVideoPublished}
                    onCheckedChange={setIsVideoPublished}
                  />
                </div>
              </div>
              

              
              <div className="flex flex-wrap gap-2 justify-center">
                <Button variant="outline" onClick={downloadRecording}>
                  <Download className="h-4 w-4 mr-2" />
                  {RECORDING.download}
                </Button>
                
                {/* Upload button - temporarily disabled */}
                {user ? (
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button variant="outline" disabled={true}>
                        <Upload className="h-4 w-4 mr-2" />
                        {RECORDING.upload}
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      {RECORDING.uploadNotSupported}
                    </TooltipContent>
                  </Tooltip>
                ) : (
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button variant="outline" disabled={true}>
                        <Upload className="h-4 w-4 mr-2" />
                        {RECORDING.upload}
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      {RECORDING.uploadNotSupported}
                    </TooltipContent>
                  </Tooltip>
                )}
                
                {/* Â≠óÂπï‰∏ãËΩΩÊåâÈíÆ */}
                {subtitleState.segments.length > 0 && (
                  <>
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={() => downloadSubtitles('srt')}
                    >
                      SRT
                    </Button>
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={() => downloadSubtitles('vtt')}
                    >
                      VTT
                    </Button>
                  </>
                )}
              </div>
              
              <div className="text-center">
                <Button onClick={startNewRecording}>
                  {RECORDING.startNewRecording}
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      )}
      
      {/* Recording Uploaded - Show Preview and Share Options */}
      {uploadedVideo && recordingState.recordedBlob && (
        <Card>
          <CardContent className="px-6 py-1">
            <div className="space-y-4">
              <div className="text-center">
                <h3 className="font-medium text-green-600">{RECORDING.uploadSuccess}</h3>
                <p className="text-sm text-muted-foreground">
                  {uploadedVideo.title}
                </p>
              </div>
              
              {/* Video Preview */}
              <div className="mx-auto max-w-md">
                <div className="aspect-video bg-muted rounded-lg overflow-hidden">
                  <video
                    className="w-full h-full object-cover"
                    controls
                    src={URL.createObjectURL(recordingState.recordedBlob)}
                  />
                </div>
              </div>
              

              
              {/* Share URL Display */}
              <div>
                <Label className="text-sm font-medium mb-2 block">{RECORDING.shareLink}</Label>
                <div className="flex space-x-2">
                  <Input
                    readOnly
                    value={getShareUrl(uploadedVideo.$id)}
                    className="flex-1"
                  />
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={() => copyShareLink(uploadedVideo.$id)}
                  >
                    <Copy className="h-4 w-4" />
                  </Button>
                </div>
              </div>
              
              {/* Action Buttons */}
              <div className="flex flex-wrap gap-2 justify-center">
                <Button variant="outline" onClick={downloadRecording}>
                  <Download className="h-4 w-4 mr-2" />
                  {RECORDING.download}
                </Button>
                <Button 
                  variant="outline" 
                  onClick={() => shareVideo(uploadedVideo)}
                >
                  <Share2 className="h-4 w-4 mr-2" />
                  {RECORDING.shareVideo}
                </Button>
                <Button 
                  variant="outline"
                  onClick={() => {
                    const shareUrl = getShareUrl(uploadedVideo.$id);
                    window.open(shareUrl, '_blank');
                  }}
                >
                  <ExternalLink className="h-4 w-4 mr-2" />
                  {RECORDING.viewVideo}
                </Button>
                
                {/* Â≠óÂπï‰∏ãËΩΩÊåâÈíÆ */}
                {subtitleState.segments.length > 0 && (
                  <>
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={() => downloadSubtitles('srt')}
                    >
                      SRT
                    </Button>
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={() => downloadSubtitles('vtt')}
                    >
                      VTT
                    </Button>
                  </>
                )}
              </div>
              
              <div className="text-center">
                <Button onClick={startNewRecording}>
                  {RECORDING.startNewRecording}
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      )}
      
      {/* ÁôªÂΩïÂºπÁ™ó */}
      <LoginModal 
        isOpen={showLoginModal}
        onClose={() => setShowLoginModal(false)}
        onSuccess={() => {
          // ÁôªÂΩïÊàêÂäüÂêéÂèØ‰ª•Âú®ËøôÈáåÂÅö‰∏Ä‰∫õÊìç‰Ωú
          console.log('ÁôªÂΩïÊàêÂäüÔºÅ');
        }}
      />

      </div>
    </TooltipProvider>
  );
}